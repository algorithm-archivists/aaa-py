<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link rel=stylesheet href="/pygments.css" type="text/css">
    <link rel=stylesheet href="/styles/style.css" type="text/css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
    <title id="ttl"></title>
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
</head>
<body>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {inlineMath: [['$','$']]}
        });
    </script>
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
    <script>
        var bjs = {"gitbook": "3.x.x", "plugins": ["fontsettings", "mathjax@https://github.com/algorithm-archivists/plugin-mathjax", "bibtex-cite", "wordcount", "api-language-selector@https://github.com/algorithm-archivists/gitbook-plugin-api-language-selector.git", "include-codeblock", "ga", "bulk-redirect", "prism", "-highlight"], "lunr": {"maxIndexSize": 1000000000}, "pluginsConfig": {"mathjax": {"version": "2.6.1"}, "include-codeblock": {"fixlang": true, "unindent": true}, "bulk-redirect": {"basepath": "/", "redirectsFile": "redirects.json"}, "ga": {"token": "UA-118252470-1"}, "prism": {"lang": {"asm-x64": "nasm"}, "ignore": ["emojicode", "text"], "css": ["prismjs/themes/prism-tomorrow.css"]}, "api-language-selector": {"languages": [{"lang": "jl", "name": "Julia", "default": true}, {"lang": "bash", "name": "Bash"}, {"lang": "cs", "name": "C#"}, {"lang": "cpp", "name": "C++"}, {"lang": "c", "name": "C"}, {"lang": "c8", "name": "chip-8"}, {"lang": "py", "name": "Python"}, {"lang": "js", "name": "JavaScript"}, {"lang": "scratch", "name": "Scratch"}, {"lang": "hs", "name": "Haskell"}, {"lang": "rs", "name": "Rust"}, {"lang": "ml", "name": "OCaml"}, {"lang": "java", "name": "Java"}, {"lang": "clj", "name": "Clojure"}, {"lang": "elm", "name": "Elm"}, {"lang": "LabVIEW", "name": "LabVIEW"}, {"lang": "d", "name": "D"}, {"lang": "go", "name": "Go"}, {"lang": "swift", "name": "Swift"}, {"lang": "racket", "name": "Racket"}, {"lang": "m", "name": "Matlab"}, {"lang": "r", "name": "R"}, {"lang": "ti83b", "name": "TI-83 Basic"}, {"lang": "lua", "name": "Lua"}, {"lang": "crystal", "name": "Crystal"}, {"lang": "php", "name": "PHP"}, {"lang": "lisp", "name": "Common Lisp"}, {"lang": "nim", "name": "Nim"}, {"lang": "asm-x64", "name": "X86-64 Assembly"}, {"lang": "f90", "name": "Fortran90"}, {"lang": "factor", "name": "Factor"}, {"lang": "ws", "name": "Whitespace"}, {"lang": "scala", "name": "Scala"}, {"lang": "emojic", "name": "Emojicode"}, {"lang": "lolcode", "name": "LOLCODE"}, {"lang": "piet", "name": "Piet"}, {"lang": "ss", "name": "Scheme"}, {"lang": "ps1", "name": "PowerShell"}, {"lang": "v", "name": "Vlang"}, {"lang": "coffee", "name": "CoffeeScript"}, {"lang": "kotlin", "name": "Kotlin"}]}}};		    
        var lang = "jl";
        var langs = {};
        var langNames = bjs.pluginsConfig["api-language-selector"].languages;
        var translations = {
            "python": "Python",
            "bf": "Brainfuck",
            "st": "Smalltalk",
            "ruby": "Ruby",
            "kotlin": "Kotlin",
            "bash": "Bash",
            "haskell": "Haskell",
            "matlab": "Matlab",
            "javascript": "JavaScript"
        };
	
        function initLangs () {
            var samples = document.getElementsByClassName("code-section");
            for (var a = 0; a < samples.length; a++) {
                var sample = samples[a];
                var children = sample.children;
                for (var b = 0; b < children.length; b++)  {
                    var element = children[b];
                    langs[element.className] = true;
                };
            };
	    langs = Object.keys(langs);
	    if (langs.length == 1) {
		lang = langs[0];
	    }
            langNames.forEach(function(element) { translations[element.lang] = element.name });
        }
        function reload() {
            var samples = document.getElementsByClassName("code-section");
            for (var a = 0; a < samples.length; a++) {
                var sample = samples[a];
                var children = sample.children;
                for (var b = 0; b < children.length; b++)  {
                    var element = children[b];
                    if (element.className == lang) {
                        element.style.display = 'block';
                    } else {
                        element.style.display = 'none';
                    }
                };
            };
        };
        window.onload = () => {
            initLangs();
            reload();
            document.getElementById("name").innerText = pages[index];
            document.getElementById("ttl").innerText = pages[index];
            initLs();
        };
        var index = 13;
        var pages = [];
	var lsed = false;
				
        function flipLs () {
            var ls = document.getElementById("ls");
            var ls2 = document.getElementById("ls2");
            if (lsed) {
                ls.style.display = 'none';
                ls2.style.display = 'none';
            } else {
                ls.style.display = 'block';
                ls2.style.display = 'block';
            }
            lsed = !lsed
        }

	var funcs = {};
        function initLs () {
            if (langs.length === 0) {
                document.getElementById("flipper").remove();
            } else {
                var h1 = 0;
                var h2 = 0;
                for (var i = 0; i < langs.length; i++) {
                    let language = langs[i];
		    console.log(language);
		    var elem = document.createElement("p");
                    funcs[language] = {}
                    funcs[language] = () => {
                        lang = language;
                        reload();
                    };
                    elem.innerHTML = "<a onclick='funcs[\"" + language + "\"]()' href='#' class=ls-link>" + translations[language] + "</a>";
                    if (i % 2) {
                        h2 += 1
                        document.getElementById("ls2").appendChild(elem);
                    } else {
                        h1 += 1
                        document.getElementById("ls").appendChild(elem);
                    }
                }
                if (h1 > h2) {
                    var elem = document.createElement("p");
                    elem.innerHTML = "&nbsp;";
                    document.getElementById("ls2").appendChild(elem);
                } else if (h2 > h1) {
                    var elem = document.createElement("p");
                    elem.innerHTML = "&nbsp;";
                    document.getElementById("ls").appendChild(elem);
                }
                document.getElementById("ls").style.display = "none";
                document.getElementById("ls2").style.display = "none";
            }
        }
        function toggleSidenav () {
            $("#sidebar").toggleClass("hide");
            $("#content").toggleClass("on-sidebar");
            $("#navbar").toggleClass("no-sidebar");
        }
    </script>
    <div class="sidebar-wrapper" id="sidebar">
        
            <p>
                
                <a name="Algorithm Archive"></a>
                <a href="/index.html#Algorithm Archive">Algorithm Archive</a>
                <script>pages[0] = "Algorithm Archive"</script>
            </p>
        
            <p>
                
                <a name="Introduction"></a>
                <a href="/contents/introduction/introduction.html#Introduction">Introduction</a>
                <script>pages[1] = "Introduction"</script>
            </p>
        
            <p>
                
                <a name="How To Contribute"></a>
                <a href="/contents/how_to_contribute/how_to_contribute.html#How To Contribute">How To Contribute</a>
                <script>pages[2] = "How To Contribute"</script>
            </p>
        
            <p>
                
                <a name="Plotting"></a>
                <a href="/contents/plotting/plotting.html#Plotting">Plotting</a>
                <script>pages[3] = "Plotting"</script>
            </p>
        
            <p>
                
                <a name="Data Structures"></a>
                <a href="/contents/data_structures/data_structures.html#Data Structures">Data Structures</a>
                <script>pages[4] = "Data Structures"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Stacks and Queues"></a>
                <a href="/contents/stacks_and_queues/stacks_and_queues.html#Stacks and Queues">Stacks and Queues</a>
                <script>pages[5] = "Stacks and Queues"</script>
            </p>
        
            <p>
                
                <a name="Mathematical Background"></a>
                <a href="/contents/mathematical_background/mathematical_background.html#Mathematical Background">Mathematical Background</a>
                <script>pages[6] = "Mathematical Background"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Complexity Notation"></a>
                <a href="/contents/notation/notation.html#Complexity Notation">Complexity Notation</a>
                <script>pages[7] = "Complexity Notation"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Bit Logic"></a>
                <a href="/contents/bitlogic/bitlogic.html#Bit Logic">Bit Logic</a>
                <script>pages[8] = "Bit Logic"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Taylor Series"></a>
                <a href="/contents/taylor_series_expansion/taylor_series_expansion.html#Taylor Series">Taylor Series</a>
                <script>pages[9] = "Taylor Series"</script>
            </p>
        
            <p>
                
                <a name="Sorting and Searching"></a>
                <a href="/contents/sorting_and_searching/sorting_and_searching.html#Sorting and Searching">Sorting and Searching</a>
                <script>pages[10] = "Sorting and Searching"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Bubble Sort"></a>
                <a href="/contents/bubble_sort/bubble_sort.html#Bubble Sort">Bubble Sort</a>
                <script>pages[11] = "Bubble Sort"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Bogo Sort"></a>
                <a href="/contents/bogo_sort/bogo_sort.html#Bogo Sort">Bogo Sort</a>
                <script>pages[12] = "Bogo Sort"</script>
            </p>
        
            <p>
                
                <a name="Tree Traversal"></a>
                <a href="/contents/tree_traversal/tree_traversal.html#Tree Traversal">Tree Traversal</a>
                <script>pages[13] = "Tree Traversal"</script>
            </p>
        
            <p>
                
                <a name="Euclidean Algorithm"></a>
                <a href="/contents/euclidean_algorithm/euclidean_algorithm.html#Euclidean Algorithm">Euclidean Algorithm</a>
                <script>pages[14] = "Euclidean Algorithm"</script>
            </p>
        
            <p>
                
                <a name="Monte Carlo"></a>
                <a href="/contents/monte_carlo_integration/monte_carlo_integration.html#Monte Carlo">Monte Carlo</a>
                <script>pages[15] = "Monte Carlo"</script>
            </p>
        
            <p>
                
                <a name="Matrix Methods"></a>
                <a href="/contents/matrix_methods/matrix_methods.html#Matrix Methods">Matrix Methods</a>
                <script>pages[16] = "Matrix Methods"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Gaussian Elimination"></a>
                <a href="/contents/gaussian_elimination/gaussian_elimination.html#Gaussian Elimination">Gaussian Elimination</a>
                <script>pages[17] = "Gaussian Elimination"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Thomas Algorithm"></a>
                <a href="/contents/thomas_algorithm/thomas_algorithm.html#Thomas Algorithm">Thomas Algorithm</a>
                <script>pages[18] = "Thomas Algorithm"</script>
            </p>
        
            <p>
                
                <a name="Computational Geometry"></a>
                <a href="/contents/computational_geometry/computational_geometry.html#Computational Geometry">Computational Geometry</a>
                <script>pages[19] = "Computational Geometry"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Gift Wrapping"></a>
                <a href="/contents/gift_wrapping/gift_wrapping.html#Gift Wrapping">Gift Wrapping</a>
                <script>pages[20] = "Gift Wrapping"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                    &nbsp;
                
                <a name="Jarvis March"></a>
                <a href="/contents/jarvis_march/jarvis_march.html#Jarvis March">Jarvis March</a>
                <script>pages[21] = "Jarvis March"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                    &nbsp;
                
                <a name="Graham Scan"></a>
                <a href="/contents/graham_scan/graham_scan.html#Graham Scan">Graham Scan</a>
                <script>pages[22] = "Graham Scan"</script>
            </p>
        
            <p>
                
                <a name="FFT"></a>
                <a href="/contents/cooley_tukey/cooley_tukey.html#FFT">FFT</a>
                <script>pages[23] = "FFT"</script>
            </p>
        
            <p>
                
                <a name="Decision Problems"></a>
                <a href="/contents/decision_problems/decision_problems.html#Decision Problems">Decision Problems</a>
                <script>pages[24] = "Decision Problems"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Stable Marriage Problem"></a>
                <a href="/contents/stable_marriage_problem/stable_marriage_problem.html#Stable Marriage Problem">Stable Marriage Problem</a>
                <script>pages[25] = "Stable Marriage Problem"</script>
            </p>
        
            <p>
                
                <a name="Differential Equation Solvers"></a>
                <a href="/contents/differential_equations/differential_equations.html#Differential Equation Solvers">Differential Equation Solvers</a>
                <script>pages[26] = "Differential Equation Solvers"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Forward Euler Method"></a>
                <a href="/contents/forward_euler_method/forward_euler_method.html#Forward Euler Method">Forward Euler Method</a>
                <script>pages[27] = "Forward Euler Method"</script>
            </p>
        
            <p>
                
                <a name="Physics Solvers"></a>
                <a href="/contents/physics_solvers/physics_solvers.html#Physics Solvers">Physics Solvers</a>
                <script>pages[28] = "Physics Solvers"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Verlet Integration"></a>
                <a href="/contents/verlet_integration/verlet_integration.html#Verlet Integration">Verlet Integration</a>
                <script>pages[29] = "Verlet Integration"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Quantum Systems"></a>
                <a href="/contents/quantum_systems/quantum_systems.html#Quantum Systems">Quantum Systems</a>
                <script>pages[30] = "Quantum Systems"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                    &nbsp;
                
                <a name="Split-Operator Method"></a>
                <a href="/contents/split-operator_method/split-operator_method.html#Split-Operator Method">Split-Operator Method</a>
                <script>pages[31] = "Split-Operator Method"</script>
            </p>
        
            <p>
                
                <a name="Data Compression"></a>
                <a href="/contents/data_compression/data_compression.html#Data Compression">Data Compression</a>
                <script>pages[32] = "Data Compression"</script>
            </p>
        
            <p>
                
                    &nbsp;
                
                <a name="Huffman Encoding"></a>
                <a href="/contents/huffman_encoding/huffman_encoding.html#Huffman Encoding">Huffman Encoding</a>
                <script>pages[33] = "Huffman Encoding"</script>
            </p>
        
            <p>
                
                <a name="Quantum Information"></a>
                <a href="/contents/quantum_information/quantum_information.html#Quantum Information">Quantum Information</a>
                <script>pages[34] = "Quantum Information"</script>
            </p>
        
        <hr>
    </div>
    <nav class="navbarrio" id=navbar>
        <ul class="navbarro">
            <li>
                <span onclick="toggleSidenav()">
                    <i class="fas fa-align-left"></i>
                </button>
            </li>
            <li>
                <span onclick="flipLs()" id=flipper>
                    <i class="fas fa-code"></i>
                    <div class=ls id=ls></div>
                    <div class=ls2 id=ls2></div>
                </span>
            </li>
            <li>
                <span id=name></span>
            </li>
        </ul>
    </nav>
    <div class="container-fluid on-sidebar" id="content">
        <h1>Tree Traversal</h1>
<p>Trees are naturally recursive data structures, and because of this, we cannot access their elements like we might access the elements of a vector or array. Instead, we need to use more interesting methods to work through each element. This is often called <em>Tree Traversal</em>, and there are many different ways to do this. For now, we will restrict the discussion to two common and related methods of tree traversal: <em>Depth-First</em> and <em>Breadth-First Search</em>. Note that trees vary greatly in shape and size depending on how they are used; however, they are composed primarily of nodes that house other, children nodes, like so:</p>
<div class=code-section>
<div class="jl">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">Node</span>
    <span class="n">children</span><span class="p">::</span><span class="n">Vector</span><span class="p">{</span><span class="n">Node</span><span class="p">}</span>
    <span class="n">ID</span><span class="p">::</span><span class="n">Int64</span>
    <span class="n">Node</span><span class="p">(</span><span class="n">ID</span><span class="p">::</span><span class="n">Int64</span><span class="p">)</span> <span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">Vector</span><span class="p">{</span><span class="n">Node</span><span class="p">}(),</span> <span class="n">ID</span><span class="p">)</span>
<span class="n">end</span>
</pre></div>

</div></p>
</div><div class="cpp">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">node</span> <span class="p">{</span>
  <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;</span> <span class="n">children</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>

</div></p>
</div><div class="cs">
<p><div class="codehilite">
<div class="highlight"><pre><span></span>    <span class="n">public</span> <span class="k">class</span> <span class="nc">Tree</span>
    <span class="p">{</span>
        <span class="n">public</span> <span class="nb">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="n">get</span><span class="p">;</span> <span class="n">private</span> <span class="nb">set</span><span class="p">;</span> <span class="p">}</span>
        <span class="n">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Tree</span><span class="o">&gt;</span> <span class="n">_children</span> <span class="o">=</span> <span class="n">new</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Tree</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>

</div></p>
</div><div class="c">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="n">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">children</span><span class="p">;</span>
    <span class="n">size_t</span> <span class="n">children_size</span><span class="p">;</span>
    <span class="nb">int</span> <span class="nb">id</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>

</div></p>
</div><div class="java">
<p><div class="codehilite">
<div class="highlight"><pre><span></span>    <span class="n">private</span> <span class="k">class</span> <span class="nc">Node</span> <span class="n">implements</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">public</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">children</span><span class="p">;</span>
        <span class="n">public</span> <span class="nb">int</span> <span class="nb">id</span><span class="p">;</span>

        <span class="n">public</span> <span class="n">Node</span><span class="p">(</span><span class="nb">int</span> <span class="nb">id</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">this</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">();</span>
            <span class="n">this</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">@Override</span>
        <span class="n">public</span> <span class="nb">int</span> <span class="n">compareTo</span><span class="p">(</span><span class="n">Node</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">//</span> <span class="n">Need</span> <span class="n">to</span> <span class="n">implement</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="ow">and</span> <span class="n">override</span> <span class="n">this</span>
            <span class="o">//</span> <span class="n">method</span> <span class="n">because</span> <span class="n">of</span> <span class="n">the</span> <span class="n">method</span> <span class="n">BFSQueue</span><span class="p">()</span> <span class="n">which</span> <span class="n">uses</span> <span class="n">Queues</span>
            <span class="o">//</span> <span class="ow">and</span> <span class="n">must</span> <span class="n">know</span> <span class="n">how</span> <span class="n">to</span> <span class="n">check</span> <span class="k">if</span> <span class="n">two</span> <span class="n">nodes</span> <span class="n">are</span> <span class="n">the</span> <span class="n">same</span> <span class="ow">or</span> <span class="ow">not</span>
            <span class="k">return</span> <span class="n">Integer</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>

</div></p>
</div><div class="js">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">createTree</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rows</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="nb">id</span><span class="p">:</span> <span class="n">rows</span><span class="p">,</span> <span class="n">children</span><span class="p">:</span> <span class="p">[]</span> <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="nb">id</span><span class="p">:</span> <span class="n">rows</span><span class="p">,</span>
    <span class="n">children</span><span class="p">:</span> <span class="p">[</span><span class="o">...</span><span class="n">Array</span><span class="p">(</span><span class="n">children</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span><span class="o">.</span><span class="n">map</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="n">createTree</span><span class="p">(</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">children</span><span class="p">))</span>
  <span class="p">};</span>
<span class="p">}</span>
</pre></div>

</div>
As a note, a <code>node</code> struct is not necessary in javascript, so this is an example of how a tree might be constructed.</p>
</div><div class="py">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>

</div></p>
</div><div class="scratch">
<p>
  <img  class="center" src="code/scratch/struct.svg" width="250" />
</p>
</div><div class="rs">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">children</span><span class="p">:</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">u64</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="hs">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">data</span> <span class="n">Tree</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Node</span>
  <span class="p">{</span> <span class="n">node</span> <span class="p">::</span> <span class="n">a</span>
  <span class="p">,</span> <span class="n">forest</span> <span class="p">::</span> <span class="p">[</span><span class="n">Tree</span> <span class="n">a</span><span class="p">]</span>
  <span class="p">}</span> <span class="n">deriving</span> <span class="p">(</span><span class="n">Show</span><span class="p">)</span>
</pre></div>

</div></p>
</div><div class="swift">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node</span> <span class="p">{</span>
    <span class="n">var</span> <span class="n">value</span><span class="p">:</span> <span class="n">Int</span>
    <span class="n">var</span> <span class="n">children</span><span class="p">:</span> <span class="p">[</span><span class="n">Node</span><span class="p">]</span><span class="err">?</span>

    <span class="n">init</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">children</span><span class="p">:</span> <span class="p">[</span><span class="n">Node</span><span class="p">])</span> <span class="p">{</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">children</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="php">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Tree</span> <span class="n">implements</span> <span class="n">JsonSerializable</span>
<span class="p">{</span>
    <span class="n">private</span> <span class="err">$</span><span class="nb">id</span><span class="p">;</span>
    <span class="n">private</span> <span class="err">$</span><span class="n">children</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="n">public</span> <span class="n">function</span> <span class="n">__construct</span><span class="p">(</span><span class="nb">int</span> <span class="err">$</span><span class="nb">id</span><span class="p">,</span> <span class="n">array</span> <span class="err">$</span><span class="n">children</span> <span class="o">=</span> <span class="p">[])</span>
    <span class="p">{</span>
        <span class="err">$</span><span class="n">this</span><span class="o">-&gt;</span><span class="nb">id</span> <span class="o">=</span> <span class="err">$</span><span class="nb">id</span><span class="p">;</span>
        <span class="err">$</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">children</span> <span class="o">=</span> <span class="err">$</span><span class="n">children</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">public</span> <span class="n">function</span> <span class="n">getId</span><span class="p">():</span> <span class="nb">int</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="err">$</span><span class="n">this</span><span class="o">-&gt;</span><span class="nb">id</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">public</span> <span class="n">function</span> <span class="n">getChildren</span><span class="p">():</span> <span class="n">array</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="err">$</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">public</span> <span class="n">function</span> <span class="n">addChild</span><span class="p">(</span><span class="n">Tree</span> <span class="err">$</span><span class="n">child</span><span class="p">):</span> <span class="n">void</span>
    <span class="p">{</span>
        <span class="err">$</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[]</span> <span class="o">=</span> <span class="err">$</span><span class="n">child</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">public</span> <span class="n">function</span> <span class="n">jsonSerialize</span><span class="p">():</span> <span class="n">array</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="s1">&#39;id&#39;</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="n">this</span><span class="o">-&gt;</span><span class="nb">id</span><span class="p">,</span>
            <span class="s1">&#39;children&#39;</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span>
        <span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="crystal">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node</span> 
  <span class="nb">property</span> <span class="nb">id</span><span class="p">,</span> <span class="n">children</span> 
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="nd">@id</span> <span class="p">:</span> <span class="n">Int32</span><span class="p">,</span> <span class="nd">@children</span> <span class="p">:</span> <span class="n">Array</span><span class="p">(</span><span class="n">Node</span><span class="p">))</span>
  <span class="n">end</span> 
<span class="n">end</span> 
</pre></div>

</div></p>
</div><div class="go">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">node</span> <span class="n">struct</span> <span class="p">{</span>
	<span class="nb">id</span>       <span class="nb">int</span>
	<span class="n">children</span> <span class="p">[]</span><span class="o">*</span><span class="n">node</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="asm-x64">
<p><div class="codehilite">
<div class="highlight"><pre><span></span>  <span class="o">.</span><span class="n">equ</span> <span class="n">tree_children</span><span class="p">,</span>     <span class="mi">0</span>
  <span class="o">.</span><span class="n">equ</span> <span class="n">tree_num_children</span><span class="p">,</span> <span class="mi">8</span>
  <span class="o">.</span><span class="n">equ</span> <span class="n">tree_value</span><span class="p">,</span>        <span class="mi">12</span>
  <span class="o">.</span><span class="n">equ</span> <span class="n">tree_size</span><span class="p">,</span>         <span class="mi">16</span>
</pre></div>

</div></p>
</div><div class="emojic">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="err">ü¶É</span> <span class="err">‚èπ</span> <span class="err">üçá</span>
  <span class="err">üîò</span> <span class="err">‚è´</span>
</pre></div>

</div></p>
</div>
</div>

<p>Because of this, the most straightforward way to traverse the tree might be recursive. This naturally leads us to the Depth-First Search (DFS) method:</p>
<div class=code-section>
<div class="jl">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">DFS_recursive</span><span class="p">(</span><span class="n">n</span><span class="p">::</span><span class="n">Node</span><span class="p">)</span>
    <span class="c1"># Here we are doing something...</span>
    <span class="n">println</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">children</span>
        <span class="n">DFS_recursive</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
    <span class="n">end</span>
<span class="n">end</span>
</pre></div>

</div></p>
</div><div class="cpp">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Simple</span> <span class="n">recursive</span> <span class="n">scheme</span> <span class="k">for</span> <span class="n">DFS</span>
<span class="n">void</span> <span class="n">dfs_recursive</span><span class="p">(</span><span class="n">node</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">Here</span> <span class="n">we</span> <span class="n">are</span> <span class="n">doing</span> <span class="n">something</span><span class="o">...</span>
  <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">auto</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">child</span> <span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dfs_recursive</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="cs">
<p><div class="codehilite">
<div class="highlight"><pre><span></span>        <span class="n">public</span> <span class="n">void</span> <span class="n">DFSRecursive</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">DFSRecursive</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

            <span class="n">void</span> <span class="n">DFSRecursive</span><span class="p">(</span><span class="n">Tree</span> <span class="n">tree</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">Id</span><span class="p">);</span>

                <span class="n">foreach</span> <span class="p">(</span><span class="n">var</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">_children</span><span class="p">)</span>
                    <span class="n">DFSRecursive</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
</pre></div>

</div></p>
</div><div class="c">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">dfs_recursive</span><span class="p">(</span><span class="n">struct</span> <span class="n">node</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">.</span><span class="n">children_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dfs_recursive</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="java">
<p><div class="codehilite">
<div class="highlight"><pre><span></span>    <span class="n">private</span> <span class="n">void</span> <span class="n">dfsRecursive</span><span class="p">(</span><span class="n">Node</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">Node</span> <span class="n">n</span> <span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dfsRecursive</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>

</div></p>
</div><div class="js">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">dfsPreorder</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
  <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">forEach</span><span class="p">(</span><span class="n">dfsPreorder</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="py">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">DFS_recursive</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">data</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
        <span class="n">DFS_recursive</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
</pre></div>

</div></p>
</div><div class="scratch">
<p>
  <img  class="center" src="code/scratch/dfs.svg" width="250" />
  <img  class="center" src="code/scratch/dfs-from.svg" width="250" />
</p>
</div><div class="rs">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">fn</span> <span class="n">dfs_recursive</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">println</span><span class="err">!</span><span class="p">(</span><span class="s2">&quot;{}&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">.</span><span class="n">children</span> <span class="p">{</span>
        <span class="n">dfs_recursive</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="hs">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">dfs</span> <span class="p">::</span> <span class="n">Tree</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">dfs</span> <span class="p">(</span><span class="n">Node</span> <span class="n">x</span> <span class="n">ts</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="p">:</span> <span class="n">concatMap</span> <span class="n">dfs</span> <span class="n">ts</span>
</pre></div>

</div></p>
</div><div class="swift">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">dfsRecursive</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="err">!</span> <span class="p">{</span>
        <span class="n">dfsRecursive</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">child</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="php">
<p><div class="codehilite">
<div class="highlight"><pre><span></span>    <span class="n">public</span> <span class="n">static</span> <span class="n">function</span> <span class="n">DFSRecursive</span><span class="p">(</span><span class="n">Tree</span> <span class="err">$</span><span class="n">tree</span><span class="p">):</span> <span class="n">void</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="err">$</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">getId</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">echo</span> <span class="err">$</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">getId</span><span class="p">()</span> <span class="o">.</span> <span class="n">PHP_EOL</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">foreach</span> <span class="p">(</span><span class="err">$</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">getChildren</span><span class="p">()</span> <span class="k">as</span> <span class="err">$</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">static</span><span class="p">::</span><span class="n">DFSRecursive</span><span class="p">(</span><span class="err">$</span><span class="n">child</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>

</div></p>
</div><div class="crystal">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dfs_recursive</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> 
  <span class="k">print</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span>
  <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">each</span><span class="p">{</span> <span class="o">|</span><span class="n">child</span><span class="o">|</span> <span class="n">dfs_recursive</span> <span class="n">child</span> <span class="p">}</span> 
<span class="n">end</span>
</pre></div>

</div></p>
</div><div class="go">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">dfsRecursive</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">child</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">n</span><span class="o">.</span><span class="n">children</span> <span class="p">{</span>
		<span class="n">dfsRecursive</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="asm-x64">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="c1"># rdi - children ptr</span>
<span class="c1"># rsi - value|children_size</span>
<span class="n">dfs_recursive</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">push</span>   <span class="n">r13</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">mov</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">rsi</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">OFFSET</span> <span class="n">fmt_tree</span>      <span class="c1"># Handle the current node</span>
  <span class="n">shr</span>    <span class="n">rsi</span><span class="p">,</span> <span class="mi">32</span>                   <span class="c1"># The tree value is in the upper 32 bits</span>
  <span class="n">xor</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>   <span class="n">printf</span>
  <span class="n">mov</span>    <span class="n">r13d</span><span class="p">,</span> <span class="n">r13d</span>                <span class="c1"># Zero out the top 32 bits</span>
  <span class="n">add</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">r12</span>                  <span class="c1"># Pointer pointing after the last element of the children array</span>
<span class="n">dfs_recursive_children</span><span class="p">:</span>
  <span class="nb">cmp</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">r13</span>                  <span class="c1"># If we reached the end, return</span>
  <span class="n">je</span>     <span class="n">dfs_recursive_return</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
  <span class="n">call</span>   <span class="n">dfs_recursive</span>
  <span class="n">add</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">tree_size</span>
  <span class="n">jmp</span>    <span class="n">dfs_recursive_children</span>
<span class="n">dfs_recursive_return</span><span class="p">:</span>
  <span class="n">pop</span>    <span class="n">r13</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">ret</span>
</pre></div>

</div></p>
</div><div class="emojic">
<p><div class="codehilite">
<div class="highlight"><pre><span></span>    <span class="err">üååüêï</span> <span class="n">depth_count</span> <span class="n">children_count</span><span class="err">‚ùóÔ∏è</span>
  <span class="err">üçâ</span>

  <span class="err">‚ùóÔ∏è</span> <span class="err">üÜî</span> <span class="err">‚û°Ô∏è</span> <span class="err">üî¢</span> <span class="err">üçá</span>
    <span class="err">‚Ü©Ô∏è</span> <span class="nb">id</span>
  <span class="err">üçâ</span>

  <span class="err">‚ùóÔ∏è</span> <span class="err">üßí</span> <span class="err">‚û°Ô∏è</span> <span class="err">üç®üêöüå≤üçÜ</span> <span class="err">üçá</span>
</pre></div>

</div></p>
</div>
</div>

<p>At least to me, this makes a lot of sense. We fight recursion with recursion! First, we first output the node we are on and then we call <code>DFS_recursive(...)</code> on each of its children nodes. This method of tree traversal does what its name implies: it goes to the depths of the tree first before going through the rest of the branches. In this case, the ordering looks like:</p>
<p>
    <img  class="center" src="res/DFS_pre.png" width="500" />
</p>

<p>Note that the in the code above, we are missing a crucial step: <em>checking to see if the node we are using actually exists!</em> Because we are using a vector to store all the nodes, we will be careful not to run into a case where we call <code>DFS_recursive(...)</code> on a node that has yet to be initialized; however, depending on the language we are using, we might need to be careful of this to avoid recursion errors!</p>
<p>Now, in this case the first element searched through is still the root of the tree. This type of tree traversal is known as <em>pre-order</em> DFS. We perform an action (output the ID) <em>before</em> searching through the children. If we shift the function around and place the data output at the end of the function, we can modify the order in which we search through the tree to be <em>post-order</em> and look something like this:</p>
<div class=code-section>
<div class="jl">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">DFS_recursive_postorder</span><span class="p">(</span><span class="n">n</span><span class="p">::</span><span class="n">Node</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">children</span>
        <span class="n">DFS_recursive_postorder</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
    <span class="n">end</span>

    <span class="c1"># Here we are doing something...</span>
    <span class="n">println</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span>
<span class="n">end</span>
</pre></div>

</div></p>
</div><div class="cpp">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">dfs_recursive_postorder</span><span class="p">(</span><span class="n">node</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">auto</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">child</span> <span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dfs_recursive_postorder</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="cs">
<p><div class="codehilite">
<div class="highlight"><pre><span></span>        <span class="n">public</span> <span class="n">void</span> <span class="n">DFSRecursivePostorder</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">DFSRecursivePostorder</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

            <span class="n">void</span> <span class="n">DFSRecursivePostorder</span><span class="p">(</span><span class="n">Tree</span> <span class="n">tree</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">foreach</span> <span class="p">(</span><span class="n">var</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">_children</span><span class="p">)</span>
                    <span class="n">DFSRecursivePostorder</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

                <span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">Id</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
</pre></div>

</div></p>
</div><div class="c">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">dfs_recursive_postorder</span><span class="p">(</span><span class="n">struct</span> <span class="n">node</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">.</span><span class="n">children_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dfs_recursive_postorder</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="java">
<p><div class="codehilite">
<div class="highlight"><pre><span></span>    <span class="n">private</span> <span class="n">void</span> <span class="n">dfsRecursivePostOrder</span><span class="p">(</span><span class="n">Node</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">Node</span> <span class="n">n</span> <span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dfsRecursivePostOrder</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="o">//</span> <span class="n">Here</span> <span class="n">we</span> <span class="n">are</span> <span class="n">doing</span> <span class="n">something</span> <span class="o">...</span>
        <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>

</div></p>
</div><div class="js">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">dfsPostorder</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">forEach</span><span class="p">(</span><span class="n">dfsPostorder</span><span class="p">);</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="py">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">DFS_recursive_postorder</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
        <span class="n">DFS_recursive_postorder</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">data</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>

</div></p>
</div><div class="scratch">
<p>
  <img  class="center" src="code/scratch/dfs-post.svg" width="300" />
</p>
</div><div class="rs">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">fn</span> <span class="n">dfs_recursive_postorder</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">.</span><span class="n">children</span> <span class="p">{</span>
        <span class="n">dfs_recursive_postorder</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">println</span><span class="err">!</span><span class="p">(</span><span class="s2">&quot;{}&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="hs">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">dfsPostOrder</span> <span class="p">::</span> <span class="n">Tree</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">dfsPostOrder</span> <span class="p">(</span><span class="n">Node</span> <span class="n">x</span> <span class="n">ts</span><span class="p">)</span> <span class="o">=</span> <span class="n">concatMap</span> <span class="n">dfsPostOrder</span> <span class="n">ts</span> <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
</pre></div>

</div></p>
</div><div class="swift">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">dfsRecursivePostOrder</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="err">!</span> <span class="p">{</span>
        <span class="n">dfsRecursivePostOrder</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">child</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="php">
<p><div class="codehilite">
<div class="highlight"><pre><span></span>    <span class="n">public</span> <span class="n">static</span> <span class="n">function</span> <span class="n">DFSRecursivePostorder</span><span class="p">(</span><span class="n">Tree</span> <span class="err">$</span><span class="n">tree</span><span class="p">):</span> <span class="n">void</span>
    <span class="p">{</span>
        <span class="n">foreach</span> <span class="p">(</span><span class="err">$</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">getChildren</span><span class="p">()</span> <span class="k">as</span> <span class="err">$</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">static</span><span class="p">::</span><span class="n">DFSRecursivePostorder</span><span class="p">(</span><span class="err">$</span><span class="n">child</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">echo</span> <span class="err">$</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">getId</span><span class="p">()</span> <span class="o">.</span> <span class="n">PHP_EOL</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>

</div></p>
</div><div class="crystal">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dfs_recursive_postorder</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> 
  <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">each</span><span class="p">{</span> <span class="o">|</span><span class="n">child</span><span class="o">|</span> <span class="n">dfs_recursive_postorder</span> <span class="n">child</span> <span class="p">}</span>
  <span class="k">print</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span> 
<span class="n">end</span> 
</pre></div>

</div></p>
</div><div class="go">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">dfsRecursivePostorder</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">child</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">n</span><span class="o">.</span><span class="n">children</span> <span class="p">{</span>
		<span class="n">dfsRecursive</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="asm-x64">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="c1"># rdi - children ptr</span>
<span class="c1"># rsi - value|children_size</span>
<span class="n">dfs_recursive_postorder</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">push</span>   <span class="n">r13</span>
  <span class="n">push</span>   <span class="n">r14</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">mov</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">rsi</span>
  <span class="n">mov</span>    <span class="n">r14</span><span class="p">,</span> <span class="n">rsi</span>
  <span class="n">mov</span>    <span class="n">r13d</span><span class="p">,</span> <span class="n">r13d</span>                <span class="c1"># Zero out the top 32 bits</span>
  <span class="n">add</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">r12</span>                  <span class="c1"># Pointer pointing after the last element of the children array</span>
<span class="n">dfs_recursive_po_children</span><span class="p">:</span>
  <span class="nb">cmp</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">r13</span>                  <span class="c1"># If we reached the end, return</span>
  <span class="n">je</span>     <span class="n">dfs_recursive_po_return</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
  <span class="n">call</span>   <span class="n">dfs_recursive_postorder</span>
  <span class="n">add</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">tree_size</span>
  <span class="n">jmp</span>    <span class="n">dfs_recursive_po_children</span>
<span class="n">dfs_recursive_po_return</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">OFFSET</span> <span class="n">fmt_tree</span>      <span class="c1"># Handle the current node</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">r14</span>
  <span class="n">shr</span>    <span class="n">rsi</span><span class="p">,</span> <span class="mi">32</span>                   <span class="c1"># The tree value is in the upper 32 bits</span>
  <span class="n">xor</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>   <span class="n">printf</span>
  <span class="n">pop</span>    <span class="n">r14</span>
  <span class="n">pop</span>    <span class="n">r13</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">ret</span>
</pre></div>

</div></p>
</div><div class="emojic">
<p><div class="codehilite">
<div class="highlight"><pre><span></span>  <span class="err">üçâ</span>

  <span class="err">üìó</span> <span class="n">Depth</span><span class="o">-</span><span class="n">First</span> <span class="n">Search</span> <span class="n">Recursive</span> <span class="n">pre</span><span class="o">-</span><span class="n">order</span> <span class="err">üìó</span>
  <span class="err">‚ùóÔ∏è</span> <span class="err">üåÄ</span> <span class="err">üçá</span>
    <span class="err">üòÄ</span> <span class="err">üî°</span> <span class="nb">id</span> <span class="mi">10</span><span class="err">‚ùóÔ∏è‚ùóÔ∏è</span>

    <span class="err">üîÇ</span> <span class="n">child</span> <span class="n">children</span> <span class="err">üçá</span>
      <span class="err">üåÄ</span> <span class="n">child</span><span class="err">‚ùóÔ∏è</span>
</pre></div>

</div></p>
</div>
</div>

<p>
    <img  class="center" src="res/DFS_post.png" width="500" />
</p>

<p>In this case, the first node visited is at the bottom of the tree and moves up the tree branch by branch. In addition to these two types, binary trees have an <em>in-order</em> traversal scheme that looks something like this:</p>
<div class=code-section>
<div class="jl">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="c1"># This assumes only 2 children, but accounts for other possibilities</span>
<span class="n">function</span> <span class="n">DFS_recursive_inorder_btree</span><span class="p">(</span><span class="n">n</span><span class="p">::</span><span class="n">Node</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">DFS_recursive_inorder_btree</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">println</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span>
        <span class="n">DFS_recursive_inorder_btree</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">elseif</span> <span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">DFS_recursive_inorder_btree</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">println</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span>
    <span class="n">elseif</span> <span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">println</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span>
    <span class="k">else</span>
        <span class="n">println</span><span class="p">(</span><span class="s2">&quot;Not a binary tree!&quot;</span><span class="p">)</span>
    <span class="n">end</span>
<span class="n">end</span>
</pre></div>

</div></p>
</div><div class="cpp">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">node</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">case</span> <span class="mi">2</span><span class="p">:</span>
      <span class="n">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
      <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">;</span>
      <span class="n">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
      <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="n">default</span><span class="p">:</span>
      <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;This is not a binary tree.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="cs">
<p><div class="codehilite">
<div class="highlight"><pre><span></span>        <span class="n">public</span> <span class="n">void</span> <span class="n">DFSRecursiveInorderBinary</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">DFSRecursiveInorderBinary</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

            <span class="o">//</span> <span class="n">This</span> <span class="n">assumes</span> <span class="n">only</span> <span class="mi">2</span> <span class="n">children</span>
            <span class="n">void</span> <span class="n">DFSRecursiveInorderBinary</span><span class="p">(</span><span class="n">Tree</span> <span class="n">tree</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">_children</span><span class="o">.</span><span class="n">Count</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="n">throw</span> <span class="n">new</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Not binary tree!&quot;</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">_children</span><span class="o">.</span><span class="n">Count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">DFSRecursiveInorderBinary</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
                    <span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">Id</span><span class="p">);</span>
                    <span class="n">DFSRecursiveInorderBinary</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
                <span class="p">}</span>
                <span class="k">else</span>
                    <span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">Id</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
</pre></div>

</div></p>
</div><div class="c">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">struct</span> <span class="n">node</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">switch</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">case</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
        <span class="n">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="n">default</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;This is not a binary tree.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="java">
<p><div class="codehilite">
<div class="highlight"><pre><span></span>    <span class="o">//</span> <span class="n">This</span> <span class="n">assumes</span> <span class="n">only</span> <span class="mi">2</span> <span class="n">children</span>
    <span class="n">private</span> <span class="n">void</span> <span class="n">dfsRecursiveInOrderBinary</span><span class="p">(</span><span class="n">Node</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">System</span><span class="o">.</span><span class="n">err</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;Not a binary tree at dfsRecursiveInOrderBinary()!&quot;</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dfsRecursiveInOrderBinary</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
            <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
            <span class="n">dfsRecursiveInOrderBinary</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>

</div></p>
</div><div class="js">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">dfsInorder</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="err">!</span><span class="n">tree</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">throw</span> <span class="n">new</span> <span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Postorder traversal is only valid for binary trees&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">dfsInorder</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
  <span class="n">dfsInorder</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="py">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="c1"># This assumes only 2 children, but accounts for other possibilities</span>
<span class="k">def</span> <span class="nf">DFS_recursive_inorder_btree</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">DFS_recursive_inorder_btree</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">DFS_recursive_inorder_btree</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">DFS_recursive_inorder_btree</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Not a binary tree!&quot;</span><span class="p">)</span>
</pre></div>

</div></p>
</div><div class="scratch">
<p>
  <img  class="center" src="code/scratch/dfs-in.svg" width="300" />
</p>
</div><div class="rs">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">fn</span> <span class="n">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">match</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="o">..</span><span class="p">]</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="n">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
            <span class="n">println</span><span class="err">!</span><span class="p">(</span><span class="s2">&quot;{}&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span><span class="p">);</span>
            <span class="n">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="n">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
            <span class="n">println</span><span class="err">!</span><span class="p">(</span><span class="s2">&quot;{}&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="p">[]</span> <span class="o">=&gt;</span> <span class="n">println</span><span class="err">!</span><span class="p">(</span><span class="s2">&quot;{}&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span><span class="p">),</span>
        <span class="n">_</span> <span class="o">=&gt;</span> <span class="n">println</span><span class="err">!</span><span class="p">(</span><span class="s2">&quot;This is not a binary tree.&quot;</span><span class="p">),</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="hs">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">dfsInOrder</span> <span class="p">::</span> <span class="n">Tree</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">--</span> <span class="n">For</span> <span class="n">binary</span> <span class="n">trees</span> <span class="n">only</span>
<span class="n">dfsInOrder</span> <span class="p">(</span><span class="n">Node</span> <span class="n">x</span> <span class="p">[])</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="n">dfsInOrder</span> <span class="p">(</span><span class="n">Node</span> <span class="n">x</span> <span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="o">=</span> <span class="n">dfsInOrder</span> <span class="n">l</span> <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">--</span> <span class="n">Single</span> <span class="n">branch</span> <span class="n">assumed</span> <span class="n">to</span> <span class="n">be</span> <span class="n">left</span>
<span class="n">dfsInOrder</span> <span class="p">(</span><span class="n">Node</span> <span class="n">x</span> <span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">])</span> <span class="o">=</span> <span class="n">dfsInOrder</span> <span class="n">l</span> <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">++</span> <span class="n">dfsInOrder</span> <span class="n">r</span>
<span class="n">dfsInOrder</span> <span class="n">_</span> <span class="o">=</span> <span class="n">error</span> <span class="s2">&quot;Not a binary tree&quot;</span>
</pre></div>

</div></p>
</div><div class="swift">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">dfsRecursiveInOrderBinary</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="err">?</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
        <span class="n">dfsRecursiveInOrderBinary</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="err">!</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">dfsRecursiveInOrderBinary</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="err">!</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="err">?</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="n">dfsRecursiveInOrderBinary</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="err">!</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="err">?</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Not a binary tree!&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="php">
<p><div class="codehilite">
<div class="highlight"><pre><span></span>    <span class="n">public</span> <span class="n">static</span> <span class="n">function</span> <span class="n">DFSRecursiveInorderBinary</span><span class="p">(</span><span class="n">Tree</span> <span class="err">$</span><span class="n">tree</span><span class="p">):</span> <span class="n">void</span>
    <span class="p">{</span>
        <span class="n">switch</span> <span class="p">(</span><span class="n">count</span><span class="p">(</span><span class="err">$</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">getChildren</span><span class="p">()))</span> <span class="p">{</span>
            <span class="n">case</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">static</span><span class="p">::</span><span class="n">DFSRecursiveInorderBinary</span><span class="p">(</span><span class="err">$</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">getChildren</span><span class="p">()[</span><span class="mi">0</span><span class="p">]);</span>
                <span class="n">echo</span> <span class="err">$</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">getId</span><span class="p">()</span> <span class="o">.</span> <span class="n">PHP_EOL</span><span class="p">;</span>
                <span class="n">static</span><span class="p">::</span><span class="n">DFSRecursiveInorderBinary</span><span class="p">(</span><span class="err">$</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">getChildren</span><span class="p">()[</span><span class="mi">1</span><span class="p">]);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="n">case</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">static</span><span class="p">::</span><span class="n">DFSRecursiveInorderBinary</span><span class="p">(</span><span class="err">$</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">getChildren</span><span class="p">()[</span><span class="mi">0</span><span class="p">]);</span>
                <span class="n">echo</span> <span class="err">$</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">getId</span><span class="p">()</span> <span class="o">.</span> <span class="n">PHP_EOL</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="n">case</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">echo</span> <span class="err">$</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">getId</span><span class="p">()</span> <span class="o">.</span> <span class="n">PHP_EOL</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="n">default</span><span class="p">:</span>
                <span class="n">throw</span> <span class="n">new</span> <span class="n">InvalidArgumentException</span><span class="p">(</span><span class="s1">&#39;Not a binary tree!&#39;</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>

</div></p>
</div><div class="crystal">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> 
  <span class="n">case</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">size</span>
  <span class="n">when</span> <span class="mi">2</span>
    <span class="n">dfs_recursive_inorder_btree</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">print</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span> 
    <span class="n">dfs_recursive_inorder_btree</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  
  <span class="n">when</span> <span class="mi">1</span> 
    <span class="n">dfs_recursive_inorder_btree</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">print</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span> 
  <span class="n">when</span> <span class="mi">0</span> 
    <span class="k">print</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span> 
  <span class="k">else</span> 
    <span class="k">print</span> <span class="s2">&quot;Not a binary tree!&quot;</span>
  <span class="n">end</span> 
<span class="n">end</span> 
</pre></div>

</div></p>
</div><div class="go">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">dfsRecursiveInorderBtree</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">switch</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">case</span> <span class="mi">2</span><span class="p">:</span>
		<span class="n">dfsRecursiveInorderBtree</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
		<span class="n">dfsRecursiveInorderBtree</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
	<span class="n">case</span> <span class="mi">1</span><span class="p">:</span>
		<span class="n">dfsRecursiveInorderBtree</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
	<span class="n">case</span> <span class="mi">0</span><span class="p">:</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
	<span class="n">default</span><span class="p">:</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s2">&quot;This is not a binary tree&quot;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="asm-x64">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="c1"># rdi - children ptr</span>
<span class="c1"># rsi - value|children_size</span>
<span class="n">dfs_recursive_inorder_btree</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">push</span>   <span class="n">r13</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">mov</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">rsi</span>
  <span class="n">mov</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rsi</span>
  <span class="n">mov</span>    <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>
  <span class="nb">cmp</span>    <span class="n">rax</span><span class="p">,</span> <span class="mi">0</span>                    <span class="c1"># Check what type of tree it is.</span>
  <span class="n">je</span>     <span class="n">dfs_recursive_bt_size0</span>
  <span class="nb">cmp</span>    <span class="n">rax</span><span class="p">,</span> <span class="mi">16</span>
  <span class="n">je</span>     <span class="n">dfs_recursive_bt_size1</span>
  <span class="nb">cmp</span>    <span class="n">rax</span><span class="p">,</span> <span class="mi">32</span>
  <span class="n">je</span>     <span class="n">dfs_recursive_bt_size2</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">OFFSET</span> <span class="n">not_bt</span>        <span class="c1"># If the tree is not binary then print a warning</span>
  <span class="n">xor</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>   <span class="n">printf</span>
  <span class="n">jmp</span>    <span class="n">dfs_recursive_bt_return</span>
<span class="n">dfs_recursive_bt_size0</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">OFFSET</span> <span class="n">fmt_tree</span>      <span class="c1"># If the node is a leaf then print its id</span>
  <span class="n">shr</span>    <span class="n">rsi</span><span class="p">,</span> <span class="mi">32</span>
  <span class="n">xor</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>   <span class="n">printf</span>
  <span class="n">jmp</span>    <span class="n">dfs_recursive_bt_return</span>
<span class="n">dfs_recursive_bt_size1</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span><span class="p">]</span>      <span class="c1"># If the node has 1 child then call the function and print the id</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
  <span class="n">call</span>   <span class="n">dfs_recursive_inorder_btree</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">OFFSET</span> <span class="n">fmt_tree</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">r13</span>
  <span class="n">shr</span>    <span class="n">rsi</span><span class="p">,</span> <span class="mi">32</span>
  <span class="n">xor</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>   <span class="n">printf</span>
  <span class="n">jmp</span>    <span class="n">dfs_recursive_bt_return</span>
<span class="n">dfs_recursive_bt_size2</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span><span class="p">]</span>     <span class="c1"># Same as above just print id inbetween the calls</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
  <span class="n">call</span>   <span class="n">dfs_recursive_inorder_btree</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">OFFSET</span> <span class="n">fmt_tree</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">r13</span>
  <span class="n">shr</span>    <span class="n">rsi</span><span class="p">,</span> <span class="mi">32</span>
  <span class="n">xor</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>   <span class="n">printf</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">24</span><span class="p">]</span>
  <span class="n">call</span>   <span class="n">dfs_recursive_inorder_btree</span>
<span class="n">dfs_recursive_bt_return</span><span class="p">:</span>
  <span class="n">pop</span>    <span class="n">r13</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">ret</span>
</pre></div>

</div></p>
</div><div class="emojic">
<p><div class="codehilite">
<div class="highlight"><pre><span></span>  <span class="err">üçâ</span>

  <span class="err">üìó</span> <span class="n">Depth</span><span class="o">-</span><span class="n">First</span> <span class="n">Search</span> <span class="n">Recursive</span> <span class="n">post</span><span class="o">-</span><span class="n">order</span> <span class="err">üìó</span>
  <span class="err">‚ùóÔ∏è</span> <span class="err">üç•</span> <span class="err">üçá</span>
    <span class="err">üîÇ</span> <span class="n">child</span> <span class="n">children</span> <span class="err">üçá</span>
      <span class="err">üç•</span> <span class="n">child</span><span class="err">‚ùóÔ∏è</span>
    <span class="err">üçâ</span>

    <span class="err">üòÄ</span> <span class="err">üî°</span> <span class="nb">id</span> <span class="mi">10</span><span class="err">‚ùóÔ∏è‚ùóÔ∏è</span>
  <span class="err">üçâ</span>

  <span class="err">üìó</span>
    <span class="n">Depth</span><span class="o">-</span><span class="n">First</span> <span class="n">Search</span> <span class="n">Recursive</span> <span class="n">Inorder</span> <span class="n">Binary</span>
    <span class="n">This</span> <span class="n">assumes</span> <span class="n">only</span> <span class="mi">2</span> <span class="n">children</span><span class="o">.</span>
  <span class="err">üìó</span>
  <span class="err">‚ùóÔ∏è</span> <span class="err">üç≠</span> <span class="err">‚û°Ô∏è</span> <span class="err">üç¨‚èπ</span> <span class="err">üçá</span>
    <span class="err">‚Ü™Ô∏è</span> <span class="err">üêî</span> <span class="n">children</span><span class="err">‚ùóÔ∏è</span> <span class="err">‚ñ∂Ô∏è</span> <span class="mi">2</span> <span class="err">üçá</span>
      <span class="err">‚Ü©Ô∏è</span> <span class="err">üÜï‚èπ‚è´‚ùóÔ∏è</span>
</pre></div>

</div></p>
</div>
</div>

<p>
    <img  class="center" src="res/DFS_in.png" width="500" />
</p>

<p>The order here seems to be some mix of the other 2 methods and works through the binary tree from left to right.</p>
<p>Now, at this point, it might seem that the only way to search through a recursive data structure is with recursion, but this is not necessarily the case! Rather surprisingly, we can perform a DFS non-recursively by using a stack, which are data structures that hold multiple elements, but only allow you to interact with the very last element you put in. The idea here is simple:</p>
<ol>
<li>Put the root node in the stack</li>
<li>Take it out and put in its children</li>
<li>Pop the top of the stack and put its children in</li>
<li>Repeat 3 until the stack is empty</li>
</ol>
<p>In code, it looks like this:</p>
<div class=code-section>
<div class="jl">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">DFS_stack</span><span class="p">(</span><span class="n">n</span><span class="p">::</span><span class="n">Node</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">{</span><span class="n">Node</span><span class="p">}()</span>
    <span class="n">push</span><span class="err">!</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">while</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">println</span><span class="p">(</span><span class="n">top</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">pop</span><span class="err">!</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">temp</span><span class="o">.</span><span class="n">children</span>
            <span class="n">push</span><span class="err">!</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
        <span class="n">end</span>
    <span class="n">end</span>
<span class="n">end</span>
</pre></div>

</div></p>
</div><div class="cpp">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">dfs_stack</span><span class="p">(</span><span class="n">node</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">this</span> <span class="n">stack</span> <span class="n">holds</span> <span class="n">pointers</span> <span class="n">into</span> <span class="n">n</span><span class="s1">&#39;s `children` vector,</span>
  <span class="o">//</span> <span class="ow">or</span> <span class="n">its</span> <span class="n">children</span><span class="s1">&#39;s `children` vector.</span>
  <span class="n">std</span><span class="p">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="n">node</span> <span class="n">const</span><span class="o">*&gt;</span> <span class="n">stack</span><span class="p">;</span>
  <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">auto</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">stack</span><span class="o">.</span><span class="n">top</span><span class="p">();</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">temp</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">auto</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">child</span> <span class="p">:</span> <span class="n">temp</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="cs">
<p><div class="codehilite">
<div class="highlight"><pre><span></span>        <span class="n">public</span> <span class="n">void</span> <span class="n">DFSStack</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">var</span> <span class="n">stack</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Tree</span><span class="o">&gt;</span><span class="p">();</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">Push</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

            <span class="k">while</span> <span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">Count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">Peek</span><span class="p">()</span><span class="o">.</span><span class="n">Id</span><span class="p">);</span>
                <span class="n">var</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">Pop</span><span class="p">();</span>

                <span class="n">foreach</span> <span class="p">(</span><span class="n">var</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">temp</span><span class="o">.</span><span class="n">_children</span><span class="p">)</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">Push</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
</pre></div>

</div></p>
</div><div class="c">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">dfs_stack</span><span class="p">(</span><span class="n">struct</span> <span class="n">node</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">struct</span> <span class="n">stack</span> <span class="n">stk</span> <span class="o">=</span> <span class="n">get_stack</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">struct</span> <span class="n">node</span><span class="o">*</span><span class="p">));</span>
    <span class="n">stack_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
    <span class="n">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="err">!</span><span class="n">stack_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stk</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct</span> <span class="n">node</span><span class="o">*</span><span class="p">)</span><span class="n">stack_pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stk</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="err">!</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="nb">id</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">children_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">stack_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">free_stack</span><span class="p">(</span><span class="n">stk</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="java">
<p><div class="codehilite">
<div class="highlight"><pre><span></span>    <span class="n">public</span> <span class="n">void</span> <span class="n">dfsStack</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">root</span><span class="p">);</span>

        <span class="n">Node</span> <span class="n">tmp</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">();</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">Node</span> <span class="n">c</span> <span class="p">:</span> <span class="n">tmp</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>

</div></p>
</div><div class="js">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">dfsIterative</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">const</span> <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">tree</span><span class="p">];</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">const</span> <span class="n">current</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">current</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="o">...</span><span class="n">current</span><span class="o">.</span><span class="n">children</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="py">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">DFS_stack</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="n">temp</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">temp</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
</pre></div>

</div></p>
</div><div class="scratch">
<p>
  <img  class="center" src="code/scratch/dfs-stack.svg" width="400" />
</p>
</div><div class="rs">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">fn</span> <span class="n">dfs_stack</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">let</span> <span class="n">mut</span> <span class="n">stack</span> <span class="o">=</span> <span class="n">vec</span><span class="err">!</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>

    <span class="k">while</span> <span class="n">let</span> <span class="n">Some</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">println</span><span class="err">!</span><span class="p">(</span><span class="s2">&quot;{}&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">.</span><span class="n">value</span><span class="p">);</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">.</span><span class="n">children</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="hs">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">dfsStack</span> <span class="p">::</span> <span class="n">Tree</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">dfsStack</span> <span class="n">t</span> <span class="o">=</span> <span class="n">go</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span>
  <span class="n">where</span>
    <span class="n">go</span> <span class="p">[]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">go</span> <span class="p">((</span><span class="n">Node</span> <span class="n">x</span> <span class="n">ts</span><span class="p">):</span><span class="n">stack</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="p">:</span> <span class="n">go</span> <span class="p">(</span><span class="n">ts</span> <span class="o">++</span> <span class="n">stack</span><span class="p">)</span>
</pre></div>

</div></p>
</div><div class="swift">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">dfsStack</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">var</span> <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span>
    <span class="n">var</span> <span class="n">temp</span><span class="p">:</span> <span class="n">Node</span>

    <span class="k">while</span> <span class="n">stack</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">popLast</span><span class="p">()</span><span class="err">!</span>
        <span class="k">print</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">temp</span><span class="o">.</span><span class="n">children</span><span class="err">!</span> <span class="p">{</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="php">
<p><div class="codehilite">
<div class="highlight"><pre><span></span>    <span class="n">public</span> <span class="n">static</span> <span class="n">function</span> <span class="n">DFSStack</span><span class="p">(</span><span class="n">Tree</span> <span class="err">$</span><span class="n">tree</span><span class="p">):</span> <span class="n">void</span>
    <span class="p">{</span>
        <span class="err">$</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="err">$</span><span class="n">tree</span><span class="p">];</span>
        <span class="err">$</span><span class="n">temp</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">null</span> <span class="o">!==</span> <span class="p">(</span><span class="err">$</span><span class="n">temp</span> <span class="o">=</span> <span class="n">array_pop</span><span class="p">(</span><span class="err">$</span><span class="n">stack</span><span class="p">)))</span> <span class="p">{</span>
            <span class="n">echo</span> <span class="err">$</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">getId</span><span class="p">()</span> <span class="o">.</span> <span class="n">PHP_EOL</span><span class="p">;</span>
            <span class="n">foreach</span> <span class="p">(</span><span class="err">$</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">getChildren</span><span class="p">()</span> <span class="k">as</span> <span class="err">$</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
                <span class="err">$</span><span class="n">stack</span><span class="p">[]</span> <span class="o">=</span> <span class="err">$</span><span class="n">child</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>

</div></p>
</div><div class="crystal">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dfs_stack</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> 
  <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span> 

  <span class="n">until</span> <span class="n">stack</span><span class="o">.</span><span class="n">empty</span><span class="err">?</span> 
    <span class="n">temp</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span> 
    <span class="k">print</span> <span class="n">temp</span><span class="o">.</span><span class="n">id</span>
    <span class="n">temp</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">each</span><span class="p">{</span> <span class="o">|</span><span class="n">child</span><span class="o">|</span> <span class="n">stack</span><span class="o">.</span><span class="n">push</span> <span class="n">child</span> <span class="p">}</span> 
  <span class="n">end</span> 
<span class="n">end</span> 
</pre></div>

</div></p>
</div><div class="go">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">dfsStack</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">stack</span> <span class="p">:</span><span class="o">=</span> <span class="p">[]</span><span class="o">*</span><span class="n">node</span><span class="p">{</span><span class="n">n</span><span class="p">}</span>

	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="n">cur</span> <span class="p">:</span><span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">stack</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
		<span class="n">stack</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="n">stack</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="asm-x64">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="c1"># rdi - children ptr</span>
<span class="c1"># rsi - value|children_size</span>
<span class="n">dfs_stack</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">push</span>   <span class="n">r13</span>
  <span class="n">push</span>   <span class="n">r14</span>
  <span class="n">sub</span>    <span class="n">rsp</span><span class="p">,</span> <span class="mi">16</span>                  <span class="c1"># Create stack</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rsp</span>
  <span class="n">push</span>   <span class="n">rsi</span>                      <span class="c1"># Save node to use as pointer</span>
  <span class="n">push</span>   <span class="n">rdi</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>
  <span class="n">call</span>   <span class="n">get_stack</span>                <span class="c1"># Init stack</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">rsp</span>
  <span class="n">call</span>   <span class="n">stack_push</span>               <span class="c1"># Push node</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>                 <span class="c1"># Pop stack</span>
  <span class="n">call</span>   <span class="n">stack_pop</span>
<span class="n">dfs_stack_loop</span><span class="p">:</span>
  <span class="n">test</span>   <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>                 <span class="c1"># Test if stack is empty</span>
  <span class="n">jz</span>     <span class="n">dfs_stack_return</span>
  <span class="n">mov</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">OFFSET</span> <span class="n">fmt_tree</span>     <span class="c1"># Print id</span>
  <span class="n">mov</span>    <span class="n">esi</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r13</span> <span class="o">+</span> <span class="mi">12</span><span class="p">]</span>
  <span class="n">xor</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>   <span class="n">printf</span>
  <span class="n">mov</span>    <span class="n">eax</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r13</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span> <span class="c1"># Get start and end of array</span>
  <span class="n">mov</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r13</span><span class="p">]</span>
  <span class="n">lea</span>    <span class="n">r14</span><span class="p">,</span> <span class="p">[</span><span class="n">r13</span> <span class="o">+</span> <span class="n">rax</span><span class="p">]</span>
<span class="n">dfs_stack_push_child</span><span class="p">:</span>
  <span class="nb">cmp</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">r14</span>                 <span class="c1"># Check if the pointers are the same</span>
  <span class="n">je</span>     <span class="n">dfs_stack_end_push</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>                 <span class="c1"># Push node into the stack</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">r13</span>
  <span class="n">call</span>   <span class="n">stack_push</span>
  <span class="n">add</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">tree_size</span>
  <span class="n">jmp</span>    <span class="n">dfs_stack_push_child</span>
<span class="n">dfs_stack_end_push</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>                 <span class="c1"># Pop stack</span>
  <span class="n">call</span>   <span class="n">stack_pop</span>
  <span class="n">jmp</span>    <span class="n">dfs_stack_loop</span>
<span class="n">dfs_stack_return</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>                 <span class="c1"># Free stack</span>
  <span class="n">call</span>   <span class="n">free_stack</span>
  <span class="n">add</span>    <span class="n">rsp</span><span class="p">,</span> <span class="mi">32</span>
  <span class="n">pop</span>    <span class="n">r14</span>
  <span class="n">pop</span>    <span class="n">r13</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">ret</span>
</pre></div>

</div></p>
</div><div class="emojic">
<p><div class="codehilite">
<div class="highlight"><pre><span></span>    <span class="err">‚Ü™Ô∏è</span> <span class="err">üêî</span> <span class="n">children</span><span class="err">‚ùóÔ∏è</span> <span class="err">‚ñ∂Ô∏è</span> <span class="mi">0</span> <span class="err">üçá</span>
      <span class="err">üç≠üêΩ</span> <span class="n">children</span> <span class="mi">0</span><span class="err">‚ùóÔ∏è‚ùóÔ∏è</span>
      <span class="err">üòÄ</span> <span class="err">üî°</span> <span class="nb">id</span> <span class="mi">10</span><span class="err">‚ùóÔ∏è‚ùóÔ∏è</span>
      <span class="err">üç≠üêΩ</span> <span class="n">children</span> <span class="mi">1</span><span class="err">‚ùóÔ∏è‚ùóÔ∏è</span>
    <span class="err">üçâ</span>
    <span class="err">üôÖ</span> <span class="err">üçá</span>
      <span class="err">üòÄ</span> <span class="err">üî°</span> <span class="nb">id</span> <span class="mi">10</span><span class="err">‚ùóÔ∏è‚ùóÔ∏è</span>
    <span class="err">üçâ</span>
    <span class="err">‚Ü©Ô∏è</span> <span class="err">ü§∑‚Äç‚ôÄÔ∏è</span>
  <span class="err">üçâ</span>

  <span class="err">üìó</span> <span class="n">Depth</span><span class="o">-</span><span class="n">First</span> <span class="n">Search</span> <span class="n">Stack</span> <span class="err">üìó</span>
  <span class="err">‚ùóÔ∏è</span> <span class="err">ü•û</span> <span class="err">üçá</span>
    <span class="err">üç®</span> <span class="err">üêï</span> <span class="err">üçÜ</span> <span class="err">‚û°Ô∏è</span> <span class="n">stack</span>
</pre></div>

</div></p>
</div>
</div>

<p>All this said, there are a few details about DFS that might not be ideal, depending on the situation. For example, if we use DFS on an incredibly long tree, we will spend a lot of time going further and further down a single branch without searching the rest of the data structure. In addition, it is not the natural way humans would order a tree if asked to number all the nodes from top to bottom. I would argue a more natural traversal order would look something like this:</p>
<p>
    <img  class="center" src="res/BFS_simple.png" width="500" />
</p>

<p>And this is exactly what Breadth-First Search (BFS) does! On top of that, it can be implemented in the same way as the <code>DFS_stack(...)</code> function above, simply by swapping the <code>stack</code> for a <code>queue</code>, which is similar to a stack, except that it only allows you to interact with the very first element instead of the last. In code, this looks something like:</p>
<div class=code-section>
<div class="jl">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">BFS_queue</span><span class="p">(</span><span class="n">n</span><span class="p">::</span><span class="n">Node</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">{</span><span class="n">Node</span><span class="p">}()</span>
    <span class="n">enqueue</span><span class="err">!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">while</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">println</span><span class="p">(</span><span class="n">front</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">dequeue</span><span class="err">!</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">temp</span><span class="o">.</span><span class="n">children</span>
            <span class="n">enqueue</span><span class="err">!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
        <span class="n">end</span>
    <span class="n">end</span>
<span class="n">end</span>
</pre></div>

</div></p>
</div><div class="cpp">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">bfs_queue</span><span class="p">(</span><span class="n">node</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="p">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">node</span> <span class="n">const</span><span class="o">*&gt;</span> <span class="n">queue</span><span class="p">;</span>
  <span class="n">queue</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">auto</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">queue</span><span class="o">.</span><span class="n">front</span><span class="p">();</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">();</span>

    <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">temp</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">auto</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">child</span> <span class="p">:</span> <span class="n">temp</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">queue</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="cs">
<p><div class="codehilite">
<div class="highlight"><pre><span></span>        <span class="n">public</span> <span class="n">void</span> <span class="n">BFSQueue</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">var</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Tree</span><span class="o">&gt;</span><span class="p">();</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">Enqueue</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

            <span class="k">while</span> <span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">Count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">Peek</span><span class="p">()</span><span class="o">.</span><span class="n">Id</span><span class="p">);</span>
                <span class="n">var</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">Dequeue</span><span class="p">();</span>

                <span class="n">foreach</span> <span class="p">(</span><span class="n">var</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">temp</span><span class="o">.</span><span class="n">_children</span><span class="p">)</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">Enqueue</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
</pre></div>

</div></p>
</div><div class="c">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">bfs_queue</span><span class="p">(</span><span class="n">struct</span> <span class="n">node</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">struct</span> <span class="n">queue</span> <span class="n">q</span> <span class="o">=</span> <span class="n">get_queue</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">struct</span> <span class="n">node</span><span class="o">*</span><span class="p">));</span>
    <span class="n">enqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
    <span class="n">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="err">!</span><span class="n">queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct</span> <span class="n">node</span><span class="o">*</span><span class="p">)</span><span class="n">dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="err">!</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="nb">id</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">children_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">enqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">free_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="java">
<p><div class="codehilite">
<div class="highlight"><pre><span></span>    <span class="n">public</span> <span class="n">void</span> <span class="n">bfsQueue</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">new</span> <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">root</span><span class="p">);</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
            <span class="n">Node</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">poll</span><span class="p">();</span> <span class="o">//</span> <span class="k">return</span> <span class="n">null</span> <span class="k">if</span> <span class="n">the</span> <span class="n">queue</span> <span class="ow">is</span> <span class="n">empty</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">Node</span> <span class="n">c</span> <span class="p">:</span> <span class="n">temp</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>

</div></p>
</div><div class="js">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">bfs</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">const</span> <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">tree</span><span class="p">];</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">const</span> <span class="n">current</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">shift</span><span class="p">();</span>
    <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">current</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="o">...</span><span class="n">current</span><span class="o">.</span><span class="n">children</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="py">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">BFS_queue</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="n">temp</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">temp</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
</pre></div>

</div></p>
</div><div class="scratch">
<p>
  <img  class="center" src="code/scratch/bfs.svg" width="400" />
</p>
</div><div class="rs">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">fn</span> <span class="n">bfs_queue</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">let</span> <span class="n">mut</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">VecDeque</span><span class="p">::</span><span class="n">new</span><span class="p">();</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

    <span class="k">while</span> <span class="n">let</span> <span class="n">Some</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop_front</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">println</span><span class="err">!</span><span class="p">(</span><span class="s2">&quot;{}&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">.</span><span class="n">value</span><span class="p">);</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">.</span><span class="n">children</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="hs">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">bfs</span> <span class="p">::</span> <span class="n">Tree</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">bfs</span> <span class="p">(</span><span class="n">Node</span> <span class="n">x</span> <span class="n">ts</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="p">:</span> <span class="n">go</span> <span class="n">ts</span>
  <span class="n">where</span>
    <span class="n">go</span> <span class="p">[]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">go</span> <span class="n">ts</span> <span class="o">=</span> <span class="nb">map</span> <span class="n">node</span> <span class="n">ts</span> <span class="o">++</span> <span class="n">go</span> <span class="p">(</span><span class="n">concatMap</span> <span class="n">forest</span> <span class="n">ts</span><span class="p">)</span>
</pre></div>

</div></p>
</div><div class="swift">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">bfsQueue</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">var</span> <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span>
    <span class="n">var</span> <span class="n">temp</span><span class="p">:</span> <span class="n">Node</span>

    <span class="k">while</span> <span class="n">queue</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">at</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">temp</span><span class="o">.</span><span class="n">children</span><span class="err">!</span> <span class="p">{</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="php">
<p><div class="codehilite">
<div class="highlight"><pre><span></span>    <span class="n">public</span> <span class="n">static</span> <span class="n">function</span> <span class="n">DFSQueue</span><span class="p">(</span><span class="n">Tree</span> <span class="err">$</span><span class="n">tree</span><span class="p">):</span> <span class="n">void</span>
    <span class="p">{</span>
        <span class="err">$</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="err">$</span><span class="n">tree</span><span class="p">];</span>
        <span class="err">$</span><span class="n">temp</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">null</span> <span class="o">!==</span> <span class="p">(</span><span class="err">$</span><span class="n">temp</span> <span class="o">=</span> <span class="n">array_shift</span><span class="p">(</span><span class="err">$</span><span class="n">stack</span><span class="p">)))</span> <span class="p">{</span>
            <span class="n">echo</span> <span class="err">$</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">getId</span><span class="p">()</span> <span class="o">.</span> <span class="n">PHP_EOL</span><span class="p">;</span>
            <span class="n">foreach</span> <span class="p">(</span><span class="err">$</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">getChildren</span><span class="p">()</span> <span class="k">as</span> <span class="err">$</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
                <span class="err">$</span><span class="n">stack</span><span class="p">[]</span> <span class="o">=</span> <span class="err">$</span><span class="n">child</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>

</div></p>
</div><div class="crystal">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bfs_queue</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> 
  <span class="n">queue</span> <span class="o">=</span> <span class="n">Deque</span><span class="o">.</span><span class="n">new</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span>

  <span class="n">until</span> <span class="n">queue</span><span class="o">.</span><span class="n">empty</span><span class="err">?</span> 
    <span class="n">temp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">shift</span>
    <span class="k">print</span> <span class="n">temp</span><span class="o">.</span><span class="n">id</span> 
    <span class="n">temp</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">each</span><span class="p">{</span> <span class="o">|</span><span class="n">child</span><span class="o">|</span> <span class="n">queue</span><span class="o">.</span><span class="n">push</span> <span class="n">child</span> <span class="p">}</span>
  <span class="n">end</span>  
<span class="n">end</span> 
</pre></div>

</div></p>
</div><div class="go">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">bfsQueue</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">queue</span> <span class="p">:</span><span class="o">=</span> <span class="p">[]</span><span class="o">*</span><span class="n">node</span><span class="p">{</span><span class="n">n</span><span class="p">}</span>

	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="n">cur</span> <span class="p">:</span><span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">queue</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
		<span class="n">queue</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">cur</span><span class="o">.</span><span class="n">children</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="asm-x64">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="c1"># rdi - children ptr</span>
<span class="c1"># rsi - value|children_size</span>
<span class="n">bfs_queue</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">push</span>   <span class="n">r13</span>
  <span class="n">push</span>   <span class="n">r14</span>
  <span class="n">sub</span>    <span class="n">rsp</span><span class="p">,</span> <span class="mi">20</span>                  <span class="c1"># Create queue</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rsp</span>
  <span class="n">push</span>   <span class="n">rsi</span>                      <span class="c1"># Save node to use as pointer</span>
  <span class="n">push</span>   <span class="n">rdi</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>
  <span class="n">call</span>   <span class="n">get_queue</span>                <span class="c1"># Init queue</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">rsp</span>
  <span class="n">call</span>   <span class="n">enqueue</span>                  <span class="c1"># enqueue node</span>
  <span class="n">mov</span>    <span class="n">eax</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">edi</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">12</span><span class="p">]</span>
<span class="n">bfs_queue_loop</span><span class="p">:</span>
  <span class="nb">cmp</span>    <span class="n">eax</span><span class="p">,</span> <span class="n">edi</span>
  <span class="n">je</span>     <span class="n">bfs_queue_return</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>                 <span class="c1"># dequeue</span>
  <span class="n">call</span>   <span class="n">dequeue</span>
  <span class="n">test</span>   <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>                 <span class="c1"># Test if queue is empty</span>
  <span class="n">jz</span>     <span class="n">bfs_queue_return</span>
  <span class="n">mov</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">OFFSET</span> <span class="n">fmt_tree</span>     <span class="c1"># Print id</span>
  <span class="n">mov</span>    <span class="n">esi</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r13</span> <span class="o">+</span> <span class="mi">12</span><span class="p">]</span>
  <span class="n">xor</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>   <span class="n">printf</span>
  <span class="n">mov</span>    <span class="n">eax</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r13</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span> <span class="c1"># Get start and end of array</span>
  <span class="n">mov</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r13</span><span class="p">]</span>
  <span class="n">lea</span>    <span class="n">r14</span><span class="p">,</span> <span class="p">[</span><span class="n">r13</span> <span class="o">+</span> <span class="n">rax</span><span class="p">]</span>
<span class="n">bfs_queue_push_child</span><span class="p">:</span>
  <span class="nb">cmp</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">r14</span>                 <span class="c1"># Check if the pointers are the same</span>
  <span class="n">je</span>     <span class="n">bfs_queue_end_push</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>                 <span class="c1"># enqueue node</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">r13</span>
  <span class="n">call</span>   <span class="n">enqueue</span>
  <span class="n">add</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">tree_size</span>
  <span class="n">jmp</span>    <span class="n">bfs_queue_push_child</span>
<span class="n">bfs_queue_end_push</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">eax</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">edi</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">12</span><span class="p">]</span>
  <span class="n">jmp</span>    <span class="n">bfs_queue_loop</span>
<span class="n">bfs_queue_return</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>                 <span class="c1"># Free queue</span>
  <span class="n">call</span>   <span class="n">free_queue</span>
  <span class="n">add</span>    <span class="n">rsp</span><span class="p">,</span> <span class="mi">36</span>
  <span class="n">pop</span>    <span class="n">r14</span>
  <span class="n">pop</span>    <span class="n">r13</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">ret</span>
</pre></div>

</div></p>
</div><div class="emojic">
<p><div class="codehilite">
<div class="highlight"><pre><span></span>      <span class="err">üêΩ</span> <span class="n">stack</span> <span class="err">üêî</span> <span class="n">stack</span><span class="err">‚ùóÔ∏è</span> <span class="err">‚ûñ</span> <span class="mi">1</span><span class="err">‚ùóÔ∏è</span> <span class="err">‚û°Ô∏è</span> <span class="n">temp</span>
      <span class="err">üê®</span> <span class="n">stack</span> <span class="err">üêî</span> <span class="n">stack</span><span class="err">‚ùóÔ∏è</span> <span class="err">‚ûñ</span> <span class="mi">1</span><span class="err">‚ùóÔ∏è</span>

      <span class="err">üòÄ</span> <span class="err">üî°</span> <span class="err">üÜî</span> <span class="n">temp</span><span class="err">‚ùóÔ∏è</span> <span class="mi">10</span><span class="err">‚ùóÔ∏è‚ùóÔ∏è</span>

      <span class="err">üßí</span> <span class="n">temp</span><span class="err">‚ùóÔ∏è</span> <span class="err">‚û°Ô∏è</span> <span class="n">temp_children</span>
      <span class="err">üîÇ</span> <span class="n">child</span> <span class="n">temp_children</span> <span class="err">üçá</span>
        <span class="err">üêª</span> <span class="n">stack</span> <span class="n">child</span><span class="err">‚ùóÔ∏è</span>
      <span class="err">üçâ</span>
    <span class="err">üçâ</span>
  <span class="err">üçâ</span>

  <span class="err">üìó</span> <span class="n">Breadth</span><span class="o">-</span><span class="n">First</span> <span class="n">Search</span> <span class="n">Queue</span> <span class="err">üìó</span>
  <span class="err">‚ùóÔ∏è</span> <span class="err">üè¢</span> <span class="err">üçá</span>
    <span class="err">üç®</span> <span class="err">üêï</span> <span class="err">üçÜ</span> <span class="err">‚û°Ô∏è</span> <span class="n">queue</span>
</pre></div>

</div></p>
</div>
</div>

<h2>Video Explanation</h2>
<p>Here is a video describing tree traversal:</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/cZPXfl_tUkA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<h2>Example Code</h2>
<div class=code-section>
<div class="jl">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">using</span> <span class="n">DataStructures</span>

<span class="n">struct</span> <span class="n">Node</span>
    <span class="n">children</span><span class="p">::</span><span class="n">Vector</span><span class="p">{</span><span class="n">Node</span><span class="p">}</span>
    <span class="n">ID</span><span class="p">::</span><span class="n">Int64</span>
    <span class="n">Node</span><span class="p">(</span><span class="n">ID</span><span class="p">::</span><span class="n">Int64</span><span class="p">)</span> <span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">Vector</span><span class="p">{</span><span class="n">Node</span><span class="p">}(),</span> <span class="n">ID</span><span class="p">)</span>
<span class="n">end</span>

<span class="n">function</span> <span class="n">DFS_recursive</span><span class="p">(</span><span class="n">n</span><span class="p">::</span><span class="n">Node</span><span class="p">)</span>
    <span class="c1"># Here we are doing something...</span>
    <span class="n">println</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">children</span>
        <span class="n">DFS_recursive</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
    <span class="n">end</span>
<span class="n">end</span>

<span class="n">function</span> <span class="n">DFS_recursive_postorder</span><span class="p">(</span><span class="n">n</span><span class="p">::</span><span class="n">Node</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">children</span>
        <span class="n">DFS_recursive_postorder</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
    <span class="n">end</span>

    <span class="c1"># Here we are doing something...</span>
    <span class="n">println</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span>
<span class="n">end</span>

<span class="c1"># This assumes only 2 children, but accounts for other possibilities</span>
<span class="n">function</span> <span class="n">DFS_recursive_inorder_btree</span><span class="p">(</span><span class="n">n</span><span class="p">::</span><span class="n">Node</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">DFS_recursive_inorder_btree</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">println</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span>
        <span class="n">DFS_recursive_inorder_btree</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">elseif</span> <span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">DFS_recursive_inorder_btree</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">println</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span>
    <span class="n">elseif</span> <span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">println</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span>
    <span class="k">else</span>
        <span class="n">println</span><span class="p">(</span><span class="s2">&quot;Not a binary tree!&quot;</span><span class="p">)</span>
    <span class="n">end</span>
<span class="n">end</span>

<span class="n">function</span> <span class="n">DFS_stack</span><span class="p">(</span><span class="n">n</span><span class="p">::</span><span class="n">Node</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">{</span><span class="n">Node</span><span class="p">}()</span>
    <span class="n">push</span><span class="err">!</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">while</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">println</span><span class="p">(</span><span class="n">top</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">pop</span><span class="err">!</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">temp</span><span class="o">.</span><span class="n">children</span>
            <span class="n">push</span><span class="err">!</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
        <span class="n">end</span>
    <span class="n">end</span>
<span class="n">end</span>

<span class="n">function</span> <span class="n">BFS_queue</span><span class="p">(</span><span class="n">n</span><span class="p">::</span><span class="n">Node</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">{</span><span class="n">Node</span><span class="p">}()</span>
    <span class="n">enqueue</span><span class="err">!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">while</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">println</span><span class="p">(</span><span class="n">front</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">dequeue</span><span class="err">!</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">temp</span><span class="o">.</span><span class="n">children</span>
            <span class="n">enqueue</span><span class="err">!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
        <span class="n">end</span>
    <span class="n">end</span>
<span class="n">end</span>

<span class="c1"># function to create a simple, balanced tree</span>
<span class="n">function</span> <span class="n">create_tree</span><span class="p">(</span><span class="n">num_row</span><span class="p">::</span><span class="n">Int64</span><span class="p">,</span> <span class="n">num_child</span><span class="p">::</span><span class="n">Int64</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">num_row</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">num_row</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>
    <span class="n">end</span>

    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">num_child</span>
        <span class="n">child</span> <span class="o">=</span> <span class="n">create_tree</span><span class="p">(</span><span class="n">num_row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_child</span><span class="p">)</span>
        <span class="n">push</span><span class="err">!</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
    <span class="n">end</span>

    <span class="k">return</span> <span class="n">ret</span>
<span class="n">end</span>

<span class="n">function</span> <span class="n">main</span><span class="p">()</span>

    <span class="n">println</span><span class="p">(</span><span class="s2">&quot;Creating Tree&quot;</span><span class="p">)</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">create_tree</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="n">println</span><span class="p">(</span><span class="s2">&quot;Using recursive DFS:&quot;</span><span class="p">)</span>
    <span class="n">DFS_recursive</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

    <span class="n">println</span><span class="p">(</span><span class="s2">&quot;Using recursive DFS with post-order traversal:&quot;</span><span class="p">)</span>
    <span class="n">DFS_recursive_postorder</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

    <span class="n">println</span><span class="p">(</span><span class="s2">&quot;Using stack-based DFS:&quot;</span><span class="p">)</span>
    <span class="n">DFS_stack</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

    <span class="n">println</span><span class="p">(</span><span class="s2">&quot;Using queue-based BFS:&quot;</span><span class="p">)</span>
    <span class="n">BFS_queue</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

    <span class="n">println</span><span class="p">(</span><span class="s2">&quot;Creating binary tree to test in-order traversal.&quot;</span><span class="p">)</span>
    <span class="n">root_binary</span> <span class="o">=</span> <span class="n">create_tree</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">println</span><span class="p">(</span><span class="s2">&quot;Using In-order DFS:&quot;</span><span class="p">)</span>
    <span class="n">DFS_recursive_inorder_btree</span><span class="p">(</span><span class="n">root_binary</span><span class="p">)</span>
<span class="n">end</span>

<span class="n">main</span><span class="p">()</span>
</pre></div>

</div></p>
</div><div class="cpp">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="c1">#include &lt;algorithm&gt;</span>
<span class="c1">#include &lt;cstddef&gt;</span>
<span class="c1">#include &lt;iostream&gt;</span>
<span class="c1">#include &lt;iterator&gt;</span>
<span class="c1">#include &lt;queue&gt;</span>
<span class="c1">#include &lt;stack&gt;</span>
<span class="c1">#include &lt;utility&gt;</span>
<span class="c1">#include &lt;vector&gt;</span>

<span class="n">using</span> <span class="n">std</span><span class="p">::</span><span class="n">size_t</span><span class="p">;</span>

<span class="n">struct</span> <span class="n">node</span> <span class="p">{</span>
  <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;</span> <span class="n">children</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="o">//</span> <span class="n">Simple</span> <span class="n">recursive</span> <span class="n">scheme</span> <span class="k">for</span> <span class="n">DFS</span>
<span class="n">void</span> <span class="n">dfs_recursive</span><span class="p">(</span><span class="n">node</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">Here</span> <span class="n">we</span> <span class="n">are</span> <span class="n">doing</span> <span class="n">something</span><span class="o">...</span>
  <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">auto</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">child</span> <span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dfs_recursive</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">dfs_recursive_postorder</span><span class="p">(</span><span class="n">node</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">auto</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">child</span> <span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dfs_recursive_postorder</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">void</span> <span class="n">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">node</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">case</span> <span class="mi">2</span><span class="p">:</span>
      <span class="n">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
      <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">;</span>
      <span class="n">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
      <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="n">default</span><span class="p">:</span>
      <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;This is not a binary tree.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">Simple</span> <span class="n">non</span><span class="o">-</span><span class="n">recursive</span> <span class="n">scheme</span> <span class="k">for</span> <span class="n">DFS</span>
<span class="n">void</span> <span class="n">dfs_stack</span><span class="p">(</span><span class="n">node</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">this</span> <span class="n">stack</span> <span class="n">holds</span> <span class="n">pointers</span> <span class="n">into</span> <span class="n">n</span><span class="s1">&#39;s `children` vector,</span>
  <span class="o">//</span> <span class="ow">or</span> <span class="n">its</span> <span class="n">children</span><span class="s1">&#39;s `children` vector.</span>
  <span class="n">std</span><span class="p">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="n">node</span> <span class="n">const</span><span class="o">*&gt;</span> <span class="n">stack</span><span class="p">;</span>
  <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">auto</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">stack</span><span class="o">.</span><span class="n">top</span><span class="p">();</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">temp</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">auto</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">child</span> <span class="p">:</span> <span class="n">temp</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">simple</span> <span class="n">non</span><span class="o">-</span><span class="n">recursive</span> <span class="n">scheme</span> <span class="k">for</span> <span class="n">BFS</span>
<span class="n">void</span> <span class="n">bfs_queue</span><span class="p">(</span><span class="n">node</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="p">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">node</span> <span class="n">const</span><span class="o">*&gt;</span> <span class="n">queue</span><span class="p">;</span>
  <span class="n">queue</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">auto</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">queue</span><span class="o">.</span><span class="n">front</span><span class="p">();</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">();</span>

    <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">temp</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">auto</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">child</span> <span class="p">:</span> <span class="n">temp</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">queue</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">node</span> <span class="n">create_tree</span><span class="p">(</span><span class="n">size_t</span> <span class="n">num_row</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">num_child</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">num_row</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">{</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;</span><span class="p">(),</span> <span class="mi">0</span><span class="p">};</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
  <span class="n">std</span><span class="p">::</span><span class="n">generate_n</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">vec</span><span class="p">),</span> <span class="n">num_child</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">create_tree</span><span class="p">(</span><span class="n">num_row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_child</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="k">return</span> <span class="n">node</span><span class="p">{</span><span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">vec</span><span class="p">),</span> <span class="n">num_row</span><span class="p">};</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">Creating</span> <span class="n">Tree</span> <span class="ow">in</span> <span class="n">main</span>
  <span class="n">auto</span> <span class="n">root</span> <span class="o">=</span> <span class="n">create_tree</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="n">auto</span> <span class="n">binary_root</span> <span class="o">=</span> <span class="n">create_tree</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;DFS recursive:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
  <span class="n">dfs_recursive</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
  <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;DFS post order recursive:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
  <span class="n">dfs_recursive_postorder</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
  <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;DFS inorder binary tree:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
  <span class="n">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">binary_root</span><span class="p">);</span>
  <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;DFS stack:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
  <span class="n">dfs_stack</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
  <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;BFS queue:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
  <span class="n">bfs_queue</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="cs">
<h5>Tree.cs</h5>
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">submitted</span> <span class="n">by</span> <span class="n">Julian</span> <span class="n">Schacher</span> <span class="p">(</span><span class="n">jspp</span><span class="p">)</span>
<span class="n">using</span> <span class="n">System</span><span class="p">;</span>
<span class="n">using</span> <span class="n">System</span><span class="o">.</span><span class="n">Collections</span><span class="o">.</span><span class="n">Generic</span><span class="p">;</span>

<span class="n">namespace</span> <span class="n">TreeTraversal</span>
<span class="p">{</span>
    <span class="n">public</span> <span class="k">class</span> <span class="nc">Tree</span>
    <span class="p">{</span>
        <span class="n">public</span> <span class="nb">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="n">get</span><span class="p">;</span> <span class="n">private</span> <span class="nb">set</span><span class="p">;</span> <span class="p">}</span>
        <span class="n">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Tree</span><span class="o">&gt;</span> <span class="n">_children</span> <span class="o">=</span> <span class="n">new</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Tree</span><span class="o">&gt;</span><span class="p">();</span>

        <span class="n">public</span> <span class="n">Tree</span><span class="p">(</span><span class="nb">int</span> <span class="n">depthCount</span><span class="p">,</span> <span class="nb">int</span> <span class="n">childrenCount</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">this</span><span class="o">.</span><span class="n">Id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="err">!</span><span class="p">(</span><span class="n">depthCount</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">childrenCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                    <span class="n">this</span><span class="o">.</span><span class="n">_children</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">new</span> <span class="n">Tree</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">Id</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">depthCount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">childrenCount</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">private</span> <span class="n">Tree</span><span class="p">(</span><span class="nb">int</span> <span class="nb">id</span><span class="p">,</span> <span class="nb">int</span> <span class="n">depthCount</span><span class="p">,</span> <span class="nb">int</span> <span class="n">childrenCount</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">this</span><span class="o">.</span><span class="n">Id</span> <span class="o">=</span> <span class="nb">id</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="err">!</span><span class="p">(</span><span class="n">depthCount</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">childrenCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                    <span class="n">this</span><span class="o">.</span><span class="n">_children</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">new</span> <span class="n">Tree</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">Id</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">depthCount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">childrenCount</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">public</span> <span class="n">void</span> <span class="n">DFSRecursive</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">DFSRecursive</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

            <span class="n">void</span> <span class="n">DFSRecursive</span><span class="p">(</span><span class="n">Tree</span> <span class="n">tree</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">Id</span><span class="p">);</span>

                <span class="n">foreach</span> <span class="p">(</span><span class="n">var</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">_children</span><span class="p">)</span>
                    <span class="n">DFSRecursive</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">public</span> <span class="n">void</span> <span class="n">DFSRecursivePostorder</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">DFSRecursivePostorder</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

            <span class="n">void</span> <span class="n">DFSRecursivePostorder</span><span class="p">(</span><span class="n">Tree</span> <span class="n">tree</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">foreach</span> <span class="p">(</span><span class="n">var</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">_children</span><span class="p">)</span>
                    <span class="n">DFSRecursivePostorder</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

                <span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">Id</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">public</span> <span class="n">void</span> <span class="n">DFSRecursiveInorderBinary</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">DFSRecursiveInorderBinary</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

            <span class="o">//</span> <span class="n">This</span> <span class="n">assumes</span> <span class="n">only</span> <span class="mi">2</span> <span class="n">children</span>
            <span class="n">void</span> <span class="n">DFSRecursiveInorderBinary</span><span class="p">(</span><span class="n">Tree</span> <span class="n">tree</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">_children</span><span class="o">.</span><span class="n">Count</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="n">throw</span> <span class="n">new</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Not binary tree!&quot;</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">_children</span><span class="o">.</span><span class="n">Count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">DFSRecursiveInorderBinary</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
                    <span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">Id</span><span class="p">);</span>
                    <span class="n">DFSRecursiveInorderBinary</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">_children</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
                <span class="p">}</span>
                <span class="k">else</span>
                    <span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">Id</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">public</span> <span class="n">void</span> <span class="n">DFSStack</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">var</span> <span class="n">stack</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Tree</span><span class="o">&gt;</span><span class="p">();</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">Push</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

            <span class="k">while</span> <span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">Count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">Peek</span><span class="p">()</span><span class="o">.</span><span class="n">Id</span><span class="p">);</span>
                <span class="n">var</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">Pop</span><span class="p">();</span>

                <span class="n">foreach</span> <span class="p">(</span><span class="n">var</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">temp</span><span class="o">.</span><span class="n">_children</span><span class="p">)</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">Push</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">public</span> <span class="n">void</span> <span class="n">BFSQueue</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">var</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Tree</span><span class="o">&gt;</span><span class="p">();</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">Enqueue</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

            <span class="k">while</span> <span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">Count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">Peek</span><span class="p">()</span><span class="o">.</span><span class="n">Id</span><span class="p">);</span>
                <span class="n">var</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">Dequeue</span><span class="p">();</span>

                <span class="n">foreach</span> <span class="p">(</span><span class="n">var</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">temp</span><span class="o">.</span><span class="n">_children</span><span class="p">)</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">Enqueue</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
<h5>Program.cs</h5>
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">submitted</span> <span class="n">by</span> <span class="n">Julian</span> <span class="n">Schacher</span> <span class="p">(</span><span class="n">jspp</span><span class="p">)</span>
<span class="n">using</span> <span class="n">System</span><span class="p">;</span>

<span class="n">namespace</span> <span class="n">TreeTraversal</span>
<span class="p">{</span>
    <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="n">static</span> <span class="n">void</span> <span class="n">Main</span><span class="p">(</span><span class="n">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s2">&quot;TreeTraversal&quot;</span><span class="p">);</span>
            <span class="n">var</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Tree</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
            <span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s2">&quot;DFSRecursive:&quot;</span><span class="p">);</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">DFSRecursive</span><span class="p">();</span>
            <span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s2">&quot;DFSStack:&quot;</span><span class="p">);</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">DFSStack</span><span class="p">();</span>
            <span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s2">&quot;BFSQueue:&quot;</span><span class="p">);</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">BFSQueue</span><span class="p">();</span>
            <span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s2">&quot;DFSRecursivePostorder&quot;</span><span class="p">);</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">DFSRecursivePostorder</span><span class="p">();</span>

            <span class="o">//</span> <span class="n">Uncommenting</span> <span class="n">the</span> <span class="n">following</span> <span class="mi">2</span> <span class="n">lines</span> <span class="n">will</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">an</span> <span class="n">exception</span> <span class="n">thrown</span> <span class="n">because</span> <span class="n">at</span> <span class="n">least</span> <span class="n">one</span> <span class="n">Node</span> <span class="n">of</span> <span class="n">the</span> <span class="n">Tree</span> <span class="n">has</span> <span class="n">more</span> <span class="n">than</span> <span class="mi">2</span> <span class="n">children</span> <span class="ow">and</span> <span class="n">therefor</span> <span class="n">a</span> <span class="n">DFSRecursiveInorderBinary</span> <span class="n">doesn</span><span class="s1">&#39;t work.</span>
            <span class="o">//</span> <span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s2">&quot;DFSRecursiveInorder (fail)&quot;</span><span class="p">);</span>
            <span class="o">//</span> <span class="n">tree</span><span class="o">.</span><span class="n">DFSRecursiveInorderBinary</span><span class="p">();</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Tree</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
            <span class="n">Console</span><span class="o">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s2">&quot;DFSRecursiveInorder (succeed)&quot;</span><span class="p">);</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">DFSRecursiveInorderBinary</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="c">
<h5>utility.h</h5>
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="c1">#ifndef UTILITY_H</span>
<span class="c1">#define UTILITY_H</span>

<span class="c1">#include &lt;stdbool.h&gt;</span>
<span class="c1">#include &lt;stddef.h&gt;</span>
<span class="c1">#include &lt;stdlib.h&gt;</span>
<span class="c1">#include &lt;string.h&gt;</span>

<span class="n">struct</span> <span class="n">stack</span> <span class="p">{</span>
    <span class="n">void</span> <span class="o">**</span><span class="n">data</span><span class="p">;</span>
    <span class="n">size_t</span> <span class="n">top</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">struct</span> <span class="n">queue</span> <span class="p">{</span>
    <span class="n">void</span> <span class="o">**</span><span class="n">data</span><span class="p">;</span>
    <span class="n">size_t</span> <span class="n">front</span><span class="p">,</span> <span class="n">back</span><span class="p">,</span> <span class="n">capacity</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">struct</span> <span class="n">stack</span> <span class="n">get_stack</span><span class="p">(</span><span class="n">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">struct</span> <span class="n">stack</span> <span class="n">stk</span><span class="p">;</span>

    <span class="n">stk</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">size</span><span class="p">);</span>
    <span class="n">stk</span><span class="o">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="n">stk</span><span class="o">.</span><span class="n">top</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">stk</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">bool</span> <span class="n">stack_empty</span><span class="p">(</span><span class="n">struct</span> <span class="n">stack</span> <span class="o">*</span><span class="n">stk</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">stk</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">stack_push</span><span class="p">(</span><span class="n">struct</span> <span class="n">stack</span> <span class="o">*</span><span class="n">stk</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">element</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">stk</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">==</span> <span class="n">stk</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">stk</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">stk</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">stk</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">stk</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">*</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">stk</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
    <span class="p">}</span>

    <span class="n">stk</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">stk</span><span class="o">-&gt;</span><span class="n">top</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span> <span class="o">*</span><span class="n">stack_pop</span><span class="p">(</span><span class="n">struct</span> <span class="n">stack</span> <span class="o">*</span><span class="n">stk</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">stack_empty</span><span class="p">(</span><span class="n">stk</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">stk</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="o">--</span><span class="n">stk</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">free_stack</span><span class="p">(</span><span class="n">struct</span> <span class="n">stack</span> <span class="n">stk</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="n">stk</span><span class="o">.</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">struct</span> <span class="n">queue</span> <span class="n">get_queue</span><span class="p">(</span><span class="n">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">struct</span> <span class="n">queue</span> <span class="n">q</span><span class="p">;</span>

    <span class="n">q</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="n">q</span><span class="o">.</span><span class="n">front</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">q</span><span class="o">.</span><span class="n">back</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">q</span><span class="o">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">q</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">bool</span> <span class="n">queue_empty</span><span class="p">(</span><span class="n">struct</span> <span class="n">queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">front</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">queue_resize</span><span class="p">(</span><span class="n">struct</span> <span class="n">queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">void</span> <span class="o">**</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">((</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span> <span class="n">size</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">,</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">-</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">)</span> <span class="o">*</span> <span class="n">size</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">tmp</span> <span class="o">+</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">-</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">front</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">size</span><span class="p">);</span>

    <span class="n">free</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>

    <span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="n">q</span><span class="o">-&gt;</span><span class="n">back</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">q</span><span class="o">-&gt;</span><span class="n">front</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">q</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">enqueue</span><span class="p">(</span><span class="n">struct</span> <span class="n">queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">element</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">front</span> <span class="o">==</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">back</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">queue_resize</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
    <span class="n">q</span><span class="o">-&gt;</span><span class="n">back</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">back</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span> <span class="o">*</span><span class="n">dequeue</span><span class="p">(</span><span class="n">struct</span> <span class="n">queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">queue_empty</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">void</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">];</span>
    <span class="n">q</span><span class="o">-&gt;</span><span class="n">front</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">front</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">free_queue</span><span class="p">(</span><span class="n">struct</span> <span class="n">queue</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">#endif //UTILITY_H</span>
</pre></div>

</div></p>
<h5>tree_traversal.c</h5>
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="c1">#include &quot;utility.h&quot;</span>

<span class="c1">#include &lt;stddef.h&gt;</span>
<span class="c1">#include &lt;stdlib.h&gt;</span>
<span class="c1">#include &lt;stdio.h&gt;</span>

<span class="n">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="n">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">children</span><span class="p">;</span>
    <span class="n">size_t</span> <span class="n">children_size</span><span class="p">;</span>
    <span class="nb">int</span> <span class="nb">id</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">struct</span> <span class="n">node</span> <span class="n">create_tree</span><span class="p">(</span><span class="nb">int</span> <span class="n">rows</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">num_children</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">struct</span> <span class="n">node</span> <span class="n">n</span> <span class="o">=</span> <span class="p">{</span><span class="n">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rows</span><span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">rows</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">n</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct</span> <span class="n">node</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">num_children</span> <span class="o">*</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">struct</span> <span class="n">node</span><span class="p">));</span>
        <span class="n">n</span><span class="o">.</span><span class="n">children_size</span> <span class="o">=</span> <span class="n">num_children</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_children</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_tree</span><span class="p">(</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_children</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">destroy_tree</span><span class="p">(</span><span class="n">struct</span> <span class="n">node</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">id</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">.</span><span class="n">children_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">destroy_tree</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="n">free</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">dfs_recursive</span><span class="p">(</span><span class="n">struct</span> <span class="n">node</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">.</span><span class="n">children_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dfs_recursive</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">dfs_recursive_postorder</span><span class="p">(</span><span class="n">struct</span> <span class="n">node</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">.</span><span class="n">children_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dfs_recursive_postorder</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">struct</span> <span class="n">node</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">switch</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">case</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
        <span class="n">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="n">case</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="n">default</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;This is not a binary tree.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">dfs_stack</span><span class="p">(</span><span class="n">struct</span> <span class="n">node</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">struct</span> <span class="n">stack</span> <span class="n">stk</span> <span class="o">=</span> <span class="n">get_stack</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">struct</span> <span class="n">node</span><span class="o">*</span><span class="p">));</span>
    <span class="n">stack_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
    <span class="n">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="err">!</span><span class="n">stack_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stk</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct</span> <span class="n">node</span><span class="o">*</span><span class="p">)</span><span class="n">stack_pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stk</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="err">!</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="nb">id</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">children_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">stack_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">free_stack</span><span class="p">(</span><span class="n">stk</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">bfs_queue</span><span class="p">(</span><span class="n">struct</span> <span class="n">node</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">struct</span> <span class="n">queue</span> <span class="n">q</span> <span class="o">=</span> <span class="n">get_queue</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">struct</span> <span class="n">node</span><span class="o">*</span><span class="p">));</span>
    <span class="n">enqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
    <span class="n">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="err">!</span><span class="n">queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">struct</span> <span class="n">node</span><span class="o">*</span><span class="p">)</span><span class="n">dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="err">!</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="nb">id</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">children_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">enqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">free_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">struct</span> <span class="n">node</span> <span class="n">root</span> <span class="o">=</span> <span class="n">create_tree</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">bfs_queue</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="n">destroy_tree</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="java">
<h5>Tree.java</h5>
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">submitted</span> <span class="n">by</span> <span class="n">xam4lor</span>
<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java.util.PriorityQueue</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java.util.Queue</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java.util.Stack</span><span class="p">;</span>

<span class="n">public</span> <span class="k">class</span> <span class="nc">Tree</span> <span class="p">{</span>
    <span class="n">public</span> <span class="n">Node</span> <span class="n">root</span><span class="p">;</span>

    <span class="n">public</span> <span class="n">Tree</span><span class="p">(</span><span class="nb">int</span> <span class="n">rowCount</span><span class="p">,</span> <span class="nb">int</span> <span class="n">childrenCount</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">//</span> <span class="n">this</span><span class="o">.</span><span class="n">root</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">root</span> <span class="n">node</span> <span class="n">of</span> <span class="n">the</span> <span class="n">Tree</span>
        <span class="n">this</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Node</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">this</span><span class="o">.</span><span class="n">createAllChildren</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">rowCount</span><span class="p">,</span> <span class="n">childrenCount</span><span class="p">);</span>
    <span class="p">}</span>


    <span class="n">public</span> <span class="n">void</span> <span class="n">dfsRecursive</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">this</span><span class="o">.</span><span class="n">dfsRecursive</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">root</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">private</span> <span class="n">void</span> <span class="n">dfsRecursive</span><span class="p">(</span><span class="n">Node</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">Node</span> <span class="n">n</span> <span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dfsRecursive</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="n">public</span> <span class="n">void</span> <span class="n">dfsRecursivePostOrder</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">this</span><span class="o">.</span><span class="n">dfsRecursivePostOrder</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">root</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">private</span> <span class="n">void</span> <span class="n">dfsRecursivePostOrder</span><span class="p">(</span><span class="n">Node</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">Node</span> <span class="n">n</span> <span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dfsRecursivePostOrder</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="o">//</span> <span class="n">Here</span> <span class="n">we</span> <span class="n">are</span> <span class="n">doing</span> <span class="n">something</span> <span class="o">...</span>
        <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
    <span class="p">}</span>


    <span class="n">public</span> <span class="n">void</span> <span class="n">dfsRecursiveInOrderBinary</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">dfsRecursiveInOrderBinary</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">root</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="o">//</span> <span class="n">This</span> <span class="n">assumes</span> <span class="n">only</span> <span class="mi">2</span> <span class="n">children</span>
    <span class="n">private</span> <span class="n">void</span> <span class="n">dfsRecursiveInOrderBinary</span><span class="p">(</span><span class="n">Node</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">System</span><span class="o">.</span><span class="n">err</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;Not a binary tree at dfsRecursiveInOrderBinary()!&quot;</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dfsRecursiveInOrderBinary</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
            <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
            <span class="n">dfsRecursiveInOrderBinary</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="n">public</span> <span class="n">void</span> <span class="n">dfsStack</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">root</span><span class="p">);</span>

        <span class="n">Node</span> <span class="n">tmp</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">();</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">Node</span> <span class="n">c</span> <span class="p">:</span> <span class="n">tmp</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">public</span> <span class="n">void</span> <span class="n">bfsQueue</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">new</span> <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">root</span><span class="p">);</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
            <span class="n">Node</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">poll</span><span class="p">();</span> <span class="o">//</span> <span class="k">return</span> <span class="n">null</span> <span class="k">if</span> <span class="n">the</span> <span class="n">queue</span> <span class="ow">is</span> <span class="n">empty</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">Node</span> <span class="n">c</span> <span class="p">:</span> <span class="n">temp</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="n">private</span> <span class="n">void</span> <span class="n">createAllChildren</span><span class="p">(</span><span class="n">Node</span> <span class="n">node</span><span class="p">,</span> <span class="nb">int</span> <span class="n">rowCount</span><span class="p">,</span> <span class="nb">int</span> <span class="n">childrenCount</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rowCount</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
           <span class="k">return</span><span class="p">;</span> 
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">childrenCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
            <span class="n">createAllChildren</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">rowCount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">childrenCount</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="n">private</span> <span class="k">class</span> <span class="nc">Node</span> <span class="n">implements</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">public</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">children</span><span class="p">;</span>
        <span class="n">public</span> <span class="nb">int</span> <span class="nb">id</span><span class="p">;</span>

        <span class="n">public</span> <span class="n">Node</span><span class="p">(</span><span class="nb">int</span> <span class="nb">id</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">this</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">();</span>
            <span class="n">this</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nd">@Override</span>
        <span class="n">public</span> <span class="nb">int</span> <span class="n">compareTo</span><span class="p">(</span><span class="n">Node</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">//</span> <span class="n">Need</span> <span class="n">to</span> <span class="n">implement</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="ow">and</span> <span class="n">override</span> <span class="n">this</span>
            <span class="o">//</span> <span class="n">method</span> <span class="n">because</span> <span class="n">of</span> <span class="n">the</span> <span class="n">method</span> <span class="n">BFSQueue</span><span class="p">()</span> <span class="n">which</span> <span class="n">uses</span> <span class="n">Queues</span>
            <span class="o">//</span> <span class="ow">and</span> <span class="n">must</span> <span class="n">know</span> <span class="n">how</span> <span class="n">to</span> <span class="n">check</span> <span class="k">if</span> <span class="n">two</span> <span class="n">nodes</span> <span class="n">are</span> <span class="n">the</span> <span class="n">same</span> <span class="ow">or</span> <span class="ow">not</span>
            <span class="k">return</span> <span class="n">Integer</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
<h5>MainClass.java</h5>
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="o">//</span><span class="n">submitted</span> <span class="n">by</span> <span class="n">xam4lor</span>
<span class="n">public</span> <span class="k">class</span> <span class="nc">MainClass</span> <span class="p">{</span>
    <span class="n">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;Creating Tree&quot;</span><span class="p">);</span>
        <span class="n">Tree</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Tree</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

        <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;Using recursive DFS :&quot;</span><span class="p">);</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">dfsRecursive</span><span class="p">();</span>

        <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;Using stack-based DFS :&quot;</span><span class="p">);</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">dfsStack</span><span class="p">();</span>

        <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;Using queue-based BFS :&quot;</span><span class="p">);</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">bfsQueue</span><span class="p">();</span>

        <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;Using post-order recursive DFS :&quot;</span><span class="p">);</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">dfsRecursivePostOrder</span><span class="p">();</span>


        <span class="o">//</span> <span class="n">Uncommenting</span> <span class="n">the</span> <span class="n">following</span> <span class="mi">2</span> <span class="n">lines</span> <span class="n">will</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">an</span> <span class="n">exception</span> <span class="n">thrown</span> <span class="n">because</span> <span class="n">at</span> <span class="n">least</span> <span class="n">one</span> <span class="n">Node</span> <span class="n">of</span> <span class="n">the</span> <span class="n">Tree</span> <span class="n">has</span> <span class="n">more</span> <span class="n">than</span> <span class="mi">2</span> <span class="n">children</span> <span class="ow">and</span> <span class="n">therefor</span> <span class="n">a</span> <span class="n">DFSRecursiveInorderBinary</span> <span class="n">doesn</span><span class="s1">&#39;t work.</span>
        <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;Using in-order binary recursive DFS : (fail)&quot;</span><span class="p">);</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">dfsRecursiveInOrderBinary</span><span class="p">();</span>

        <span class="n">tree</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Tree</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;Using in-order binary recursive DFS : (succeed)&quot;</span><span class="p">);</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">dfsRecursiveInOrderBinary</span><span class="p">();</span>


        <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="js">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">createTree</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rows</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="nb">id</span><span class="p">:</span> <span class="n">rows</span><span class="p">,</span> <span class="n">children</span><span class="p">:</span> <span class="p">[]</span> <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="nb">id</span><span class="p">:</span> <span class="n">rows</span><span class="p">,</span>
    <span class="n">children</span><span class="p">:</span> <span class="p">[</span><span class="o">...</span><span class="n">Array</span><span class="p">(</span><span class="n">children</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span><span class="o">.</span><span class="n">map</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="n">createTree</span><span class="p">(</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">children</span><span class="p">))</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="n">function</span> <span class="n">dfsPreorder</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
  <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">forEach</span><span class="p">(</span><span class="n">dfsPreorder</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">function</span> <span class="n">dfsPostorder</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">forEach</span><span class="p">(</span><span class="n">dfsPostorder</span><span class="p">);</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">function</span> <span class="n">dfsInorder</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="err">!</span><span class="n">tree</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">throw</span> <span class="n">new</span> <span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Postorder traversal is only valid for binary trees&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">dfsInorder</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
  <span class="n">dfsInorder</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>

<span class="n">function</span> <span class="n">dfsIterative</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">const</span> <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">tree</span><span class="p">];</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">const</span> <span class="n">current</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">current</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="o">...</span><span class="n">current</span><span class="o">.</span><span class="n">children</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">function</span> <span class="n">bfs</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">const</span> <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">tree</span><span class="p">];</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">const</span> <span class="n">current</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">shift</span><span class="p">();</span>
    <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">current</span><span class="o">.</span><span class="n">id</span><span class="p">);</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="o">...</span><span class="n">current</span><span class="o">.</span><span class="n">children</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">const</span> <span class="n">root</span> <span class="o">=</span> <span class="n">createTree</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">dfsPreorder</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
<span class="n">dfsPostorder</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
<span class="n">dfsIterative</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
<span class="n">bfs</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
</pre></div>

</div></p>
</div><div class="py">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>


<span class="k">def</span> <span class="nf">create_tree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">num_row</span><span class="p">,</span> <span class="n">num_child</span><span class="p">):</span>
    <span class="n">node</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">num_row</span>

    <span class="k">if</span> <span class="n">num_row</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_child</span><span class="p">):</span>
            <span class="n">child</span> <span class="o">=</span> <span class="n">create_tree</span><span class="p">(</span><span class="n">Node</span><span class="p">(),</span> <span class="n">num_row</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_child</span><span class="p">)</span>
            <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">node</span>


<span class="k">def</span> <span class="nf">DFS_recursive</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">data</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
        <span class="n">DFS_recursive</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">DFS_recursive_postorder</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
        <span class="n">DFS_recursive_postorder</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">data</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>


<span class="c1"># This assumes only 2 children, but accounts for other possibilities</span>
<span class="k">def</span> <span class="nf">DFS_recursive_inorder_btree</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">DFS_recursive_inorder_btree</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">DFS_recursive_inorder_btree</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">DFS_recursive_inorder_btree</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Not a binary tree!&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">DFS_stack</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="n">temp</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">temp</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">BFS_queue</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="n">temp</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">temp</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">create_tree</span><span class="p">(</span><span class="n">Node</span><span class="p">(),</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Recursive:&quot;</span><span class="p">)</span>
    <span class="n">DFS_recursive</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Recursive Postorder:&quot;</span><span class="p">)</span>
    <span class="n">DFS_recursive_postorder</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Stack:&quot;</span><span class="p">)</span>
    <span class="n">DFS_stack</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Queue:&quot;</span><span class="p">)</span>
    <span class="n">BFS_queue</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>

    <span class="n">binaryTree</span> <span class="o">=</span> <span class="n">create_tree</span><span class="p">(</span><span class="n">Node</span><span class="p">(),</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Recursive Inorder Binary Tree:&quot;</span><span class="p">)</span>
    <span class="n">DFS_recursive_inorder_btree</span><span class="p">(</span><span class="n">binaryTree</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>

</div></p>
</div><div class="scratch">
<p>The code snippets were taken from this <a href="https://scratch.mit.edu/projects/174017753/">Scratch project</a></p>
</div><div class="rs">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">use</span> <span class="n">std</span><span class="p">::</span><span class="n">collections</span><span class="p">::</span><span class="n">VecDeque</span><span class="p">;</span>

<span class="c1">#[derive(Debug)]</span>
<span class="n">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">children</span><span class="p">:</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">u64</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">fn</span> <span class="n">dfs_recursive</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">println</span><span class="err">!</span><span class="p">(</span><span class="s2">&quot;{}&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">.</span><span class="n">children</span> <span class="p">{</span>
        <span class="n">dfs_recursive</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">fn</span> <span class="n">dfs_recursive_postorder</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">.</span><span class="n">children</span> <span class="p">{</span>
        <span class="n">dfs_recursive_postorder</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">println</span><span class="err">!</span><span class="p">(</span><span class="s2">&quot;{}&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">fn</span> <span class="n">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">match</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="o">..</span><span class="p">]</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="n">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
            <span class="n">println</span><span class="err">!</span><span class="p">(</span><span class="s2">&quot;{}&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span><span class="p">);</span>
            <span class="n">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="n">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
            <span class="n">println</span><span class="err">!</span><span class="p">(</span><span class="s2">&quot;{}&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="p">[]</span> <span class="o">=&gt;</span> <span class="n">println</span><span class="err">!</span><span class="p">(</span><span class="s2">&quot;{}&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span><span class="p">),</span>
        <span class="n">_</span> <span class="o">=&gt;</span> <span class="n">println</span><span class="err">!</span><span class="p">(</span><span class="s2">&quot;This is not a binary tree.&quot;</span><span class="p">),</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">fn</span> <span class="n">dfs_stack</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">let</span> <span class="n">mut</span> <span class="n">stack</span> <span class="o">=</span> <span class="n">vec</span><span class="err">!</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>

    <span class="k">while</span> <span class="n">let</span> <span class="n">Some</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">println</span><span class="err">!</span><span class="p">(</span><span class="s2">&quot;{}&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">.</span><span class="n">value</span><span class="p">);</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">.</span><span class="n">children</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">fn</span> <span class="n">bfs_queue</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">let</span> <span class="n">mut</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">VecDeque</span><span class="p">::</span><span class="n">new</span><span class="p">();</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

    <span class="k">while</span> <span class="n">let</span> <span class="n">Some</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop_front</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">println</span><span class="err">!</span><span class="p">(</span><span class="s2">&quot;{}&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">.</span><span class="n">value</span><span class="p">);</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">.</span><span class="n">children</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">fn</span> <span class="n">create_tree</span><span class="p">(</span><span class="n">num_row</span><span class="p">:</span> <span class="n">u64</span><span class="p">,</span> <span class="n">num_child</span><span class="p">:</span> <span class="n">u64</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">num_row</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Node</span> <span class="p">{</span>
            <span class="n">children</span><span class="p">:</span> <span class="n">vec</span><span class="err">!</span><span class="p">[],</span>
            <span class="n">value</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">};</span>
    <span class="p">}</span>

    <span class="n">let</span> <span class="n">children</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.</span><span class="o">.</span><span class="n">num_child</span><span class="p">)</span>
        <span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span> <span class="n">create_tree</span><span class="p">(</span><span class="n">num_row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_child</span><span class="p">))</span>
        <span class="o">.</span><span class="n">collect</span><span class="p">();</span>

    <span class="n">Node</span> <span class="p">{</span>
        <span class="n">children</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">num_row</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">let</span> <span class="n">root</span> <span class="o">=</span> <span class="n">create_tree</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

    <span class="n">println</span><span class="err">!</span><span class="p">(</span><span class="s2">&quot;Recursive DFS:&quot;</span><span class="p">);</span>
    <span class="n">dfs_recursive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="p">);</span>

    <span class="n">println</span><span class="err">!</span><span class="p">(</span><span class="s2">&quot;Stack DFS:&quot;</span><span class="p">);</span>
    <span class="n">dfs_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="p">);</span>

    <span class="n">println</span><span class="err">!</span><span class="p">(</span><span class="s2">&quot;Queue BFS:&quot;</span><span class="p">);</span>
    <span class="n">bfs_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="p">);</span>

    <span class="n">println</span><span class="err">!</span><span class="p">(</span><span class="s2">&quot;Recursive post-order DFS:&quot;</span><span class="p">);</span>
    <span class="n">dfs_recursive_postorder</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="p">);</span>

    <span class="n">println</span><span class="err">!</span><span class="p">(</span><span class="s2">&quot;Recursive in-order DFS BTree:&quot;</span><span class="p">);</span>
    <span class="n">let</span> <span class="n">root_binary</span> <span class="o">=</span> <span class="n">create_tree</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_binary</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="hs">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">data</span> <span class="n">Tree</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Node</span>
  <span class="p">{</span> <span class="n">node</span> <span class="p">::</span> <span class="n">a</span>
  <span class="p">,</span> <span class="n">forest</span> <span class="p">::</span> <span class="p">[</span><span class="n">Tree</span> <span class="n">a</span><span class="p">]</span>
  <span class="p">}</span> <span class="n">deriving</span> <span class="p">(</span><span class="n">Show</span><span class="p">)</span>

<span class="n">dfs</span> <span class="p">::</span> <span class="n">Tree</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">dfs</span> <span class="p">(</span><span class="n">Node</span> <span class="n">x</span> <span class="n">ts</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="p">:</span> <span class="n">concatMap</span> <span class="n">dfs</span> <span class="n">ts</span>

<span class="n">dfsPostOrder</span> <span class="p">::</span> <span class="n">Tree</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">dfsPostOrder</span> <span class="p">(</span><span class="n">Node</span> <span class="n">x</span> <span class="n">ts</span><span class="p">)</span> <span class="o">=</span> <span class="n">concatMap</span> <span class="n">dfsPostOrder</span> <span class="n">ts</span> <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>

<span class="n">dfsInOrder</span> <span class="p">::</span> <span class="n">Tree</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">--</span> <span class="n">For</span> <span class="n">binary</span> <span class="n">trees</span> <span class="n">only</span>
<span class="n">dfsInOrder</span> <span class="p">(</span><span class="n">Node</span> <span class="n">x</span> <span class="p">[])</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="n">dfsInOrder</span> <span class="p">(</span><span class="n">Node</span> <span class="n">x</span> <span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="o">=</span> <span class="n">dfsInOrder</span> <span class="n">l</span> <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">--</span> <span class="n">Single</span> <span class="n">branch</span> <span class="n">assumed</span> <span class="n">to</span> <span class="n">be</span> <span class="n">left</span>
<span class="n">dfsInOrder</span> <span class="p">(</span><span class="n">Node</span> <span class="n">x</span> <span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">])</span> <span class="o">=</span> <span class="n">dfsInOrder</span> <span class="n">l</span> <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">++</span> <span class="n">dfsInOrder</span> <span class="n">r</span>
<span class="n">dfsInOrder</span> <span class="n">_</span> <span class="o">=</span> <span class="n">error</span> <span class="s2">&quot;Not a binary tree&quot;</span>

<span class="n">dfsStack</span> <span class="p">::</span> <span class="n">Tree</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">dfsStack</span> <span class="n">t</span> <span class="o">=</span> <span class="n">go</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span>
  <span class="n">where</span>
    <span class="n">go</span> <span class="p">[]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">go</span> <span class="p">((</span><span class="n">Node</span> <span class="n">x</span> <span class="n">ts</span><span class="p">):</span><span class="n">stack</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="p">:</span> <span class="n">go</span> <span class="p">(</span><span class="n">ts</span> <span class="o">++</span> <span class="n">stack</span><span class="p">)</span>

<span class="n">bfs</span> <span class="p">::</span> <span class="n">Tree</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">bfs</span> <span class="p">(</span><span class="n">Node</span> <span class="n">x</span> <span class="n">ts</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="p">:</span> <span class="n">go</span> <span class="n">ts</span>
  <span class="n">where</span>
    <span class="n">go</span> <span class="p">[]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">go</span> <span class="n">ts</span> <span class="o">=</span> <span class="nb">map</span> <span class="n">node</span> <span class="n">ts</span> <span class="o">++</span> <span class="n">go</span> <span class="p">(</span><span class="n">concatMap</span> <span class="n">forest</span> <span class="n">ts</span><span class="p">)</span>

<span class="n">toBin</span> <span class="p">::</span> <span class="n">Tree</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">Tree</span> <span class="n">a</span>
<span class="n">toBin</span> <span class="p">(</span><span class="n">Node</span> <span class="n">x</span> <span class="n">ts</span><span class="p">)</span> <span class="o">=</span> <span class="n">Node</span> <span class="n">x</span> <span class="p">(</span><span class="nb">map</span> <span class="n">toBin</span> <span class="err">$</span> <span class="n">take</span> <span class="mi">2</span> <span class="n">ts</span><span class="p">)</span>

<span class="n">main</span> <span class="o">=</span> <span class="n">do</span>
  <span class="k">print</span> <span class="err">$</span> <span class="n">dfs</span> <span class="n">testTree</span>
  <span class="k">print</span> <span class="err">$</span> <span class="n">dfsPostOrder</span> <span class="n">testTree</span>
  <span class="k">print</span> <span class="err">$</span> <span class="n">dfsInOrder</span> <span class="err">$</span> <span class="n">toBin</span> <span class="n">testTree</span>
  <span class="k">print</span> <span class="err">$</span> <span class="n">dfsStack</span> <span class="n">testTree</span>
  <span class="k">print</span> <span class="err">$</span> <span class="n">bfs</span> <span class="n">testTree</span>

<span class="n">testTree</span> <span class="p">::</span> <span class="n">Tree</span> <span class="n">Int</span>
<span class="n">testTree</span> <span class="o">=</span>
  <span class="n">Node</span>
    <span class="mi">1</span>
    <span class="p">[</span> <span class="n">Node</span> <span class="mi">2</span> <span class="p">[</span><span class="n">Node</span> <span class="mi">3</span> <span class="p">[],</span> <span class="n">Node</span> <span class="mi">4</span> <span class="p">[</span><span class="n">Node</span> <span class="mi">5</span> <span class="p">[]]]</span>
    <span class="p">,</span> <span class="n">Node</span>
        <span class="mi">6</span>
        <span class="p">[</span> <span class="n">Node</span> <span class="mi">7</span> <span class="p">[]</span>
        <span class="p">,</span> <span class="n">Node</span> <span class="mi">8</span> <span class="p">[</span><span class="n">Node</span> <span class="mi">9</span> <span class="p">[</span><span class="n">Node</span> <span class="mi">10</span> <span class="p">[</span><span class="n">Node</span> <span class="mi">11</span> <span class="p">[]],</span> <span class="n">Node</span> <span class="mi">12</span> <span class="p">[]]]</span>
        <span class="p">,</span> <span class="n">Node</span> <span class="mi">13</span> <span class="p">[</span><span class="n">Node</span> <span class="mi">14</span> <span class="p">[]]</span>
        <span class="p">]</span>
    <span class="p">,</span> <span class="n">Node</span> <span class="mi">15</span> <span class="p">[]</span>
    <span class="p">]</span>
</pre></div>

</div></p>
</div><div class="swift">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node</span> <span class="p">{</span>
    <span class="n">var</span> <span class="n">value</span><span class="p">:</span> <span class="n">Int</span>
    <span class="n">var</span> <span class="n">children</span><span class="p">:</span> <span class="p">[</span><span class="n">Node</span><span class="p">]</span><span class="err">?</span>

    <span class="n">init</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">children</span><span class="p">:</span> <span class="p">[</span><span class="n">Node</span><span class="p">])</span> <span class="p">{</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">children</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">createTree</span><span class="p">(</span><span class="n">numRows</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">numChildren</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">let</span> <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">numRows</span><span class="p">,</span> <span class="n">children</span><span class="p">:</span> <span class="p">[])</span>

    <span class="k">if</span> <span class="n">numRows</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">..</span><span class="n">numChildren</span> <span class="p">{</span>
            <span class="n">let</span> <span class="n">child</span> <span class="o">=</span> <span class="n">createTree</span><span class="p">(</span><span class="n">numRows</span><span class="p">:</span> <span class="n">numRows</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">numChildren</span><span class="p">:</span> <span class="n">numChildren</span><span class="p">)</span>
            <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="err">?</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">node</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">dfsRecursive</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="err">!</span> <span class="p">{</span>
        <span class="n">dfsRecursive</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">child</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">dfsRecursivePostOrder</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="err">!</span> <span class="p">{</span>
        <span class="n">dfsRecursivePostOrder</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">child</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">dfsRecursiveInOrderBinary</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="err">?</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
        <span class="n">dfsRecursiveInOrderBinary</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="err">!</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">dfsRecursiveInOrderBinary</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="err">!</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="err">?</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="n">dfsRecursiveInOrderBinary</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="err">!</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="err">?</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Not a binary tree!&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">dfsStack</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">var</span> <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span>
    <span class="n">var</span> <span class="n">temp</span><span class="p">:</span> <span class="n">Node</span>

    <span class="k">while</span> <span class="n">stack</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">popLast</span><span class="p">()</span><span class="err">!</span>
        <span class="k">print</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">temp</span><span class="o">.</span><span class="n">children</span><span class="err">!</span> <span class="p">{</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">bfsQueue</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">var</span> <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span>
    <span class="n">var</span> <span class="n">temp</span><span class="p">:</span> <span class="n">Node</span>

    <span class="k">while</span> <span class="n">queue</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">at</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">temp</span><span class="o">.</span><span class="n">children</span><span class="err">!</span> <span class="p">{</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">let</span> <span class="n">root</span> <span class="o">=</span> <span class="n">createTree</span><span class="p">(</span><span class="n">numRows</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">numChildren</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Using recursive DFS:&quot;</span><span class="p">)</span>
    <span class="n">dfsRecursive</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">root</span><span class="p">)</span>
    
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Using recursive postorder DFS:&quot;</span><span class="p">)</span>
    <span class="n">dfsRecursivePostOrder</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">root</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Using stack-based DFS:&quot;</span><span class="p">)</span>
    <span class="n">dfsStack</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">root</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Using queue-based BFS:&quot;</span><span class="p">)</span>
    <span class="n">bfsQueue</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">root</span><span class="p">)</span>

    <span class="n">let</span> <span class="n">rootBinary</span> <span class="o">=</span> <span class="n">createTree</span><span class="p">(</span><span class="n">numRows</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">numChildren</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Using In-order DFS:&quot;</span><span class="p">)</span>
    <span class="n">dfsRecursiveInOrderBinary</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">rootBinary</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">main</span><span class="p">()</span>
</pre></div>

</div></p>
</div><div class="php">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="err">?</span><span class="n">php</span>
<span class="n">declare</span><span class="p">(</span><span class="n">strict_types</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>

<span class="k">class</span> <span class="nc">Tree</span> <span class="n">implements</span> <span class="n">JsonSerializable</span>
<span class="p">{</span>
    <span class="n">private</span> <span class="err">$</span><span class="nb">id</span><span class="p">;</span>
    <span class="n">private</span> <span class="err">$</span><span class="n">children</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="n">public</span> <span class="n">function</span> <span class="n">__construct</span><span class="p">(</span><span class="nb">int</span> <span class="err">$</span><span class="nb">id</span><span class="p">,</span> <span class="n">array</span> <span class="err">$</span><span class="n">children</span> <span class="o">=</span> <span class="p">[])</span>
    <span class="p">{</span>
        <span class="err">$</span><span class="n">this</span><span class="o">-&gt;</span><span class="nb">id</span> <span class="o">=</span> <span class="err">$</span><span class="nb">id</span><span class="p">;</span>
        <span class="err">$</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">children</span> <span class="o">=</span> <span class="err">$</span><span class="n">children</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">public</span> <span class="n">function</span> <span class="n">getId</span><span class="p">():</span> <span class="nb">int</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="err">$</span><span class="n">this</span><span class="o">-&gt;</span><span class="nb">id</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">public</span> <span class="n">function</span> <span class="n">getChildren</span><span class="p">():</span> <span class="n">array</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="err">$</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">public</span> <span class="n">function</span> <span class="n">addChild</span><span class="p">(</span><span class="n">Tree</span> <span class="err">$</span><span class="n">child</span><span class="p">):</span> <span class="n">void</span>
    <span class="p">{</span>
        <span class="err">$</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[]</span> <span class="o">=</span> <span class="err">$</span><span class="n">child</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">public</span> <span class="n">function</span> <span class="n">jsonSerialize</span><span class="p">():</span> <span class="n">array</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="s1">&#39;id&#39;</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="n">this</span><span class="o">-&gt;</span><span class="nb">id</span><span class="p">,</span>
            <span class="s1">&#39;children&#39;</span> <span class="o">=&gt;</span> <span class="err">$</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span>
        <span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">TreeTraversal</span>
<span class="p">{</span>
    <span class="n">public</span> <span class="n">static</span> <span class="n">function</span> <span class="n">DFSRecursive</span><span class="p">(</span><span class="n">Tree</span> <span class="err">$</span><span class="n">tree</span><span class="p">):</span> <span class="n">void</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="err">$</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">getId</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">echo</span> <span class="err">$</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">getId</span><span class="p">()</span> <span class="o">.</span> <span class="n">PHP_EOL</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">foreach</span> <span class="p">(</span><span class="err">$</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">getChildren</span><span class="p">()</span> <span class="k">as</span> <span class="err">$</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">static</span><span class="p">::</span><span class="n">DFSRecursive</span><span class="p">(</span><span class="err">$</span><span class="n">child</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">public</span> <span class="n">static</span> <span class="n">function</span> <span class="n">DFSRecursivePostorder</span><span class="p">(</span><span class="n">Tree</span> <span class="err">$</span><span class="n">tree</span><span class="p">):</span> <span class="n">void</span>
    <span class="p">{</span>
        <span class="n">foreach</span> <span class="p">(</span><span class="err">$</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">getChildren</span><span class="p">()</span> <span class="k">as</span> <span class="err">$</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">static</span><span class="p">::</span><span class="n">DFSRecursivePostorder</span><span class="p">(</span><span class="err">$</span><span class="n">child</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">echo</span> <span class="err">$</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">getId</span><span class="p">()</span> <span class="o">.</span> <span class="n">PHP_EOL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">public</span> <span class="n">static</span> <span class="n">function</span> <span class="n">DFSRecursiveInorderBinary</span><span class="p">(</span><span class="n">Tree</span> <span class="err">$</span><span class="n">tree</span><span class="p">):</span> <span class="n">void</span>
    <span class="p">{</span>
        <span class="n">switch</span> <span class="p">(</span><span class="n">count</span><span class="p">(</span><span class="err">$</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">getChildren</span><span class="p">()))</span> <span class="p">{</span>
            <span class="n">case</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">static</span><span class="p">::</span><span class="n">DFSRecursiveInorderBinary</span><span class="p">(</span><span class="err">$</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">getChildren</span><span class="p">()[</span><span class="mi">0</span><span class="p">]);</span>
                <span class="n">echo</span> <span class="err">$</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">getId</span><span class="p">()</span> <span class="o">.</span> <span class="n">PHP_EOL</span><span class="p">;</span>
                <span class="n">static</span><span class="p">::</span><span class="n">DFSRecursiveInorderBinary</span><span class="p">(</span><span class="err">$</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">getChildren</span><span class="p">()[</span><span class="mi">1</span><span class="p">]);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="n">case</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">static</span><span class="p">::</span><span class="n">DFSRecursiveInorderBinary</span><span class="p">(</span><span class="err">$</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">getChildren</span><span class="p">()[</span><span class="mi">0</span><span class="p">]);</span>
                <span class="n">echo</span> <span class="err">$</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">getId</span><span class="p">()</span> <span class="o">.</span> <span class="n">PHP_EOL</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="n">case</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">echo</span> <span class="err">$</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">getId</span><span class="p">()</span> <span class="o">.</span> <span class="n">PHP_EOL</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="n">default</span><span class="p">:</span>
                <span class="n">throw</span> <span class="n">new</span> <span class="n">InvalidArgumentException</span><span class="p">(</span><span class="s1">&#39;Not a binary tree!&#39;</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">public</span> <span class="n">static</span> <span class="n">function</span> <span class="n">DFSStack</span><span class="p">(</span><span class="n">Tree</span> <span class="err">$</span><span class="n">tree</span><span class="p">):</span> <span class="n">void</span>
    <span class="p">{</span>
        <span class="err">$</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="err">$</span><span class="n">tree</span><span class="p">];</span>
        <span class="err">$</span><span class="n">temp</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">null</span> <span class="o">!==</span> <span class="p">(</span><span class="err">$</span><span class="n">temp</span> <span class="o">=</span> <span class="n">array_pop</span><span class="p">(</span><span class="err">$</span><span class="n">stack</span><span class="p">)))</span> <span class="p">{</span>
            <span class="n">echo</span> <span class="err">$</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">getId</span><span class="p">()</span> <span class="o">.</span> <span class="n">PHP_EOL</span><span class="p">;</span>
            <span class="n">foreach</span> <span class="p">(</span><span class="err">$</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">getChildren</span><span class="p">()</span> <span class="k">as</span> <span class="err">$</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
                <span class="err">$</span><span class="n">stack</span><span class="p">[]</span> <span class="o">=</span> <span class="err">$</span><span class="n">child</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">public</span> <span class="n">static</span> <span class="n">function</span> <span class="n">DFSQueue</span><span class="p">(</span><span class="n">Tree</span> <span class="err">$</span><span class="n">tree</span><span class="p">):</span> <span class="n">void</span>
    <span class="p">{</span>
        <span class="err">$</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="err">$</span><span class="n">tree</span><span class="p">];</span>
        <span class="err">$</span><span class="n">temp</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">null</span> <span class="o">!==</span> <span class="p">(</span><span class="err">$</span><span class="n">temp</span> <span class="o">=</span> <span class="n">array_shift</span><span class="p">(</span><span class="err">$</span><span class="n">stack</span><span class="p">)))</span> <span class="p">{</span>
            <span class="n">echo</span> <span class="err">$</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">getId</span><span class="p">()</span> <span class="o">.</span> <span class="n">PHP_EOL</span><span class="p">;</span>
            <span class="n">foreach</span> <span class="p">(</span><span class="err">$</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">getChildren</span><span class="p">()</span> <span class="k">as</span> <span class="err">$</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
                <span class="err">$</span><span class="n">stack</span><span class="p">[]</span> <span class="o">=</span> <span class="err">$</span><span class="n">child</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">function</span> <span class="n">generate_tree</span><span class="p">(</span><span class="nb">int</span> <span class="err">$</span><span class="n">numOfRows</span><span class="p">,</span> <span class="nb">int</span> <span class="err">$</span><span class="n">numOfChildren</span><span class="p">,</span> <span class="nb">int</span> <span class="err">$</span><span class="nb">id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="n">Tree</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="err">$</span><span class="nb">id</span> <span class="o">===</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="err">$</span><span class="nb">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="err">$</span><span class="n">node</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Tree</span><span class="p">(</span><span class="err">$</span><span class="nb">id</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="err">$</span><span class="n">numOfRows</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="err">$</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="err">$</span><span class="n">i</span> <span class="o">&lt;</span> <span class="err">$</span><span class="n">numOfChildren</span><span class="p">;</span> <span class="err">$</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="err">$</span><span class="n">child</span> <span class="o">=</span> <span class="n">generate_tree</span><span class="p">(</span><span class="err">$</span><span class="n">numOfRows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="err">$</span><span class="n">numOfChildren</span><span class="p">,</span> <span class="err">$</span><span class="nb">id</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="err">$</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="err">$</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span><span class="err">$</span><span class="n">child</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="err">$</span><span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="err">$</span><span class="n">node</span> <span class="o">=</span> <span class="n">generate_tree</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

<span class="n">echo</span> <span class="s1">&#39;DFS Recursive:&#39;</span> <span class="o">.</span> <span class="n">PHP_EOL</span><span class="p">;</span>
<span class="n">TreeTraversal</span><span class="p">::</span><span class="n">DFSRecursive</span><span class="p">(</span><span class="err">$</span><span class="n">node</span><span class="p">);</span>

<span class="n">echo</span> <span class="s1">&#39;DFS Recursive Postorder:&#39;</span> <span class="o">.</span> <span class="n">PHP_EOL</span><span class="p">;</span>
<span class="n">TreeTraversal</span><span class="p">::</span><span class="n">DFSRecursivePostorder</span><span class="p">(</span><span class="err">$</span><span class="n">node</span><span class="p">);</span>

<span class="n">echo</span> <span class="s1">&#39;DFS Stack:&#39;</span> <span class="o">.</span> <span class="n">PHP_EOL</span><span class="p">;</span>
<span class="n">TreeTraversal</span><span class="p">::</span><span class="n">DFSStack</span><span class="p">(</span><span class="err">$</span><span class="n">node</span><span class="p">);</span>

<span class="n">echo</span> <span class="s1">&#39;DFS Queue:&#39;</span> <span class="o">.</span> <span class="n">PHP_EOL</span><span class="p">;</span>
<span class="n">TreeTraversal</span><span class="p">::</span><span class="n">DFSQueue</span><span class="p">(</span><span class="err">$</span><span class="n">node</span><span class="p">);</span>

<span class="o">//</span> <span class="n">If</span> <span class="n">you</span> <span class="n">want</span> <span class="n">to</span> <span class="k">try</span> <span class="n">to</span> <span class="n">run</span> <span class="n">binary</span> <span class="n">order</span> <span class="n">on</span> <span class="n">a</span> <span class="n">non</span><span class="o">-</span><span class="n">binary</span> <span class="n">tree</span><span class="p">,</span>
<span class="o">//</span> <span class="n">comment</span> <span class="n">out</span> <span class="n">the</span> <span class="n">generation</span> <span class="n">of</span> <span class="n">the</span> <span class="n">new</span> <span class="n">tree</span> <span class="n">below</span><span class="o">.</span>
<span class="o">//</span> <span class="n">If</span> <span class="n">you</span> <span class="n">do</span> <span class="n">that</span><span class="p">,</span> <span class="n">an</span> <span class="n">exception</span> <span class="n">will</span> <span class="n">be</span> <span class="n">thrown</span>
<span class="err">$</span><span class="n">node</span> <span class="o">=</span> <span class="n">generate_tree</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">echo</span> <span class="s1">&#39;DFS Recursive Inorder Binary:&#39;</span> <span class="o">.</span> <span class="n">PHP_EOL</span><span class="p">;</span>
<span class="n">TreeTraversal</span><span class="p">::</span><span class="n">DFSRecursiveInorderBinary</span><span class="p">(</span><span class="err">$</span><span class="n">node</span><span class="p">);</span>
</pre></div>

</div></p>
</div><div class="crystal">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node</span> 
  <span class="nb">property</span> <span class="nb">id</span><span class="p">,</span> <span class="n">children</span> 
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="nd">@id</span> <span class="p">:</span> <span class="n">Int32</span><span class="p">,</span> <span class="nd">@children</span> <span class="p">:</span> <span class="n">Array</span><span class="p">(</span><span class="n">Node</span><span class="p">))</span>
  <span class="n">end</span> 
<span class="n">end</span> 

<span class="k">def</span> <span class="nf">dfs_recursive</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> 
  <span class="k">print</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span>
  <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">each</span><span class="p">{</span> <span class="o">|</span><span class="n">child</span><span class="o">|</span> <span class="n">dfs_recursive</span> <span class="n">child</span> <span class="p">}</span> 
<span class="n">end</span>

<span class="k">def</span> <span class="nf">dfs_recursive_postorder</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> 
  <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">each</span><span class="p">{</span> <span class="o">|</span><span class="n">child</span><span class="o">|</span> <span class="n">dfs_recursive_postorder</span> <span class="n">child</span> <span class="p">}</span>
  <span class="k">print</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span> 
<span class="n">end</span> 

<span class="k">def</span> <span class="nf">dfs_recursive_inorder_btree</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> 
  <span class="n">case</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">size</span>
  <span class="n">when</span> <span class="mi">2</span>
    <span class="n">dfs_recursive_inorder_btree</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">print</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span> 
    <span class="n">dfs_recursive_inorder_btree</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  
  <span class="n">when</span> <span class="mi">1</span> 
    <span class="n">dfs_recursive_inorder_btree</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">print</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span> 
  <span class="n">when</span> <span class="mi">0</span> 
    <span class="k">print</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span> 
  <span class="k">else</span> 
    <span class="k">print</span> <span class="s2">&quot;Not a binary tree!&quot;</span>
  <span class="n">end</span> 
<span class="n">end</span> 

<span class="k">def</span> <span class="nf">dfs_stack</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> 
  <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span> 

  <span class="n">until</span> <span class="n">stack</span><span class="o">.</span><span class="n">empty</span><span class="err">?</span> 
    <span class="n">temp</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span> 
    <span class="k">print</span> <span class="n">temp</span><span class="o">.</span><span class="n">id</span>
    <span class="n">temp</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">each</span><span class="p">{</span> <span class="o">|</span><span class="n">child</span><span class="o">|</span> <span class="n">stack</span><span class="o">.</span><span class="n">push</span> <span class="n">child</span> <span class="p">}</span> 
  <span class="n">end</span> 
<span class="n">end</span> 

<span class="k">def</span> <span class="nf">bfs_queue</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> 
  <span class="n">queue</span> <span class="o">=</span> <span class="n">Deque</span><span class="o">.</span><span class="n">new</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span>

  <span class="n">until</span> <span class="n">queue</span><span class="o">.</span><span class="n">empty</span><span class="err">?</span> 
    <span class="n">temp</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">shift</span>
    <span class="k">print</span> <span class="n">temp</span><span class="o">.</span><span class="n">id</span> 
    <span class="n">temp</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">each</span><span class="p">{</span> <span class="o">|</span><span class="n">child</span><span class="o">|</span> <span class="n">queue</span><span class="o">.</span><span class="n">push</span> <span class="n">child</span> <span class="p">}</span>
  <span class="n">end</span>  
<span class="n">end</span> 

<span class="k">def</span> <span class="nf">create_tree</span><span class="p">(</span><span class="n">levels</span><span class="p">,</span> <span class="n">num_childs</span><span class="p">)</span> 

  <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span> <span class="n">of</span> <span class="n">Node</span>  
  <span class="n">unless</span> <span class="n">levels</span> <span class="o">==</span> <span class="mi">0</span> 
    <span class="n">num_childs</span><span class="o">.</span><span class="n">times</span><span class="p">{</span><span class="n">children</span><span class="o">.</span><span class="n">push</span> <span class="n">create_tree</span> <span class="n">levels</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_childs</span> <span class="p">}</span> 
  <span class="n">end</span> 
  
  <span class="n">Node</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">levels</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span> 
<span class="n">end</span>

<span class="k">def</span> <span class="nf">print_tree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="p">[]</span> <span class="n">of</span> <span class="n">String</span><span class="p">)</span> 
  <span class="n">puts</span> <span class="s2">&quot;(#{node.id})&quot;</span>
  <span class="n">depth</span><span class="o">.</span><span class="n">push</span> <span class="s2">&quot; &quot;</span> 
  <span class="nb">len</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span>

  <span class="p">(</span><span class="mi">0</span> <span class="o">..</span> <span class="nb">len</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="n">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
    <span class="n">depth</span><span class="o">.</span><span class="n">each</span><span class="p">{</span><span class="o">|</span><span class="n">c</span><span class="o">|</span> <span class="k">print</span> <span class="n">c</span><span class="p">}</span> 
    <span class="n">unless</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span> 
      <span class="k">print</span> <span class="s2">&quot;‚îú&quot;</span> 
      <span class="n">depth</span><span class="o">.</span><span class="n">push</span> <span class="s2">&quot;‚îÇ&quot;</span>
      <span class="n">print_tree</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">depth</span>
      <span class="n">depth</span><span class="o">.</span><span class="n">pop</span> 
    <span class="k">else</span> 
      <span class="k">print</span> <span class="s2">&quot;‚îî&quot;</span>
      <span class="n">depth</span><span class="o">.</span><span class="n">push</span> <span class="s2">&quot; &quot;</span> 
      <span class="n">print_tree</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">depth</span>
      <span class="n">depth</span><span class="o">.</span><span class="n">pop</span>
    <span class="n">end</span> 
  <span class="n">end</span> 
  <span class="n">depth</span><span class="o">.</span><span class="n">pop</span> 
<span class="n">end</span> 

<span class="k">def</span> <span class="nf">main</span> 
  <span class="n">puts</span> <span class="s2">&quot;Creating Tree&quot;</span> 
  <span class="n">root</span> <span class="o">=</span> <span class="n">create_tree</span> <span class="n">levels</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">num_childs</span><span class="p">:</span> <span class="mi">3</span>
  <span class="n">print_tree</span> <span class="n">root</span> 

  <span class="n">puts</span> <span class="s2">&quot;Using recursive DFS:&quot;</span>
  <span class="n">dfs_recursive</span> <span class="n">root</span>
  <span class="n">puts</span>  

  <span class="n">puts</span> <span class="s2">&quot;Using recursive DFS with post-order traversal:&quot;</span> 
  <span class="n">dfs_recursive_postorder</span> <span class="n">root</span> 
  <span class="n">puts</span>  

  <span class="n">puts</span> <span class="s2">&quot;Using stack-based DFS:&quot;</span>
  <span class="n">dfs_stack</span> <span class="n">root</span> 
  <span class="n">puts</span>  

  <span class="n">puts</span> <span class="s2">&quot;Using queue-based BFS:&quot;</span>
  <span class="n">bfs_queue</span> <span class="n">root</span> 
  <span class="n">puts</span>  

  <span class="n">puts</span> <span class="s2">&quot;Creating binary tree to test in-order traversal&quot;</span>
  <span class="n">root_bin</span> <span class="o">=</span> <span class="n">create_tree</span> <span class="n">levels</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">num_childs</span><span class="p">:</span> <span class="mi">2</span>
  <span class="n">print_tree</span> <span class="n">root_bin</span> 

  <span class="n">puts</span> <span class="s2">&quot;Using In-order DFS:&quot;</span>
  <span class="n">dfs_recursive_inorder_btree</span> <span class="n">root_bin</span>
  <span class="n">puts</span>
<span class="n">end</span> 

<span class="n">main</span>
</pre></div>

</div></p>
</div><div class="go">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="n">package</span> <span class="n">main</span>

<span class="kn">import</span> <span class="s2">&quot;fmt&quot;</span>

<span class="nb">type</span> <span class="n">node</span> <span class="n">struct</span> <span class="p">{</span>
	<span class="nb">id</span>       <span class="nb">int</span>
	<span class="n">children</span> <span class="p">[]</span><span class="o">*</span><span class="n">node</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">dfsRecursive</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">child</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">n</span><span class="o">.</span><span class="n">children</span> <span class="p">{</span>
		<span class="n">dfsRecursive</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">dfsRecursivePostorder</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">child</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">n</span><span class="o">.</span><span class="n">children</span> <span class="p">{</span>
		<span class="n">dfsRecursive</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">dfsRecursiveInorderBtree</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">switch</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">case</span> <span class="mi">2</span><span class="p">:</span>
		<span class="n">dfsRecursiveInorderBtree</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
		<span class="n">dfsRecursiveInorderBtree</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
	<span class="n">case</span> <span class="mi">1</span><span class="p">:</span>
		<span class="n">dfsRecursiveInorderBtree</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
	<span class="n">case</span> <span class="mi">0</span><span class="p">:</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
	<span class="n">default</span><span class="p">:</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s2">&quot;This is not a binary tree&quot;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">dfsStack</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">stack</span> <span class="p">:</span><span class="o">=</span> <span class="p">[]</span><span class="o">*</span><span class="n">node</span><span class="p">{</span><span class="n">n</span><span class="p">}</span>

	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="n">cur</span> <span class="p">:</span><span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">stack</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
		<span class="n">stack</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="n">stack</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">bfsQueue</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">queue</span> <span class="p">:</span><span class="o">=</span> <span class="p">[]</span><span class="o">*</span><span class="n">node</span><span class="p">{</span><span class="n">n</span><span class="p">}</span>

	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="n">cur</span> <span class="p">:</span><span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">queue</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
		<span class="n">queue</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">cur</span><span class="o">.</span><span class="n">children</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">createTree</span><span class="p">(</span><span class="n">numRow</span><span class="p">,</span> <span class="n">numChild</span> <span class="nb">int</span><span class="p">)</span> <span class="o">*</span><span class="n">node</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">numRow</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">node</span><span class="p">{</span><span class="nb">id</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
	<span class="p">}</span>

	<span class="n">cur</span> <span class="p">:</span><span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
	<span class="n">cur</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">numRow</span>

	<span class="k">for</span> <span class="n">x</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">numChild</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">cur</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">cur</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="n">createTree</span><span class="p">(</span><span class="n">numRow</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">numChild</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">cur</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">root</span> <span class="p">:</span><span class="o">=</span> <span class="n">createTree</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="n">binTree</span> <span class="p">:</span><span class="o">=</span> <span class="n">createTree</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s2">&quot;DFS recursive:&quot;</span><span class="p">)</span>
	<span class="n">dfsRecursive</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s2">&quot;DFS post order recursive:&quot;</span><span class="p">)</span>
	<span class="n">dfsRecursivePostorder</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s2">&quot;DFS inorder binary tree:&quot;</span><span class="p">)</span>
	<span class="n">dfsRecursiveInorderBtree</span><span class="p">(</span><span class="n">binTree</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s2">&quot;DFS stack:&quot;</span><span class="p">)</span>
	<span class="n">dfsStack</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s2">&quot;BFS queue:&quot;</span><span class="p">)</span>
	<span class="n">bfsQueue</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

</div></p>
</div><div class="asm-x64">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="o">.</span><span class="n">intel_syntax</span> <span class="n">noprefix</span>

<span class="c1"># System V calling convention cheatsheet</span>
<span class="c1"># Params: rdi, rsi, rdx, rcx, r8, r9, xmm0-7</span>
<span class="c1"># Return: rax (int 64 bits), rax:rdx (int 128 bits), xmm0 (float)</span>
<span class="c1"># Callee cleanup: rbx, rbp, r12-15</span>
<span class="c1"># Scratch: rax, rdi, rsi, rdx, rcx, r8, r9, r10, r11</span>

<span class="o">.</span><span class="n">section</span> <span class="o">.</span><span class="n">rodata</span>
  <span class="n">not_bt</span><span class="p">:</span>     <span class="o">.</span><span class="n">string</span> <span class="s2">&quot;This is not a binary tree.</span><span class="se">\n</span><span class="s2">&quot;</span>
  <span class="n">fmt_tree</span><span class="p">:</span>   <span class="o">.</span><span class="n">string</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span>

  <span class="o">.</span><span class="n">equ</span> <span class="n">stack_size</span><span class="p">,</span>  <span class="mi">16</span>
  <span class="o">.</span><span class="n">equ</span> <span class="n">stack_array</span><span class="p">,</span> <span class="mi">0</span>
  <span class="o">.</span><span class="n">equ</span> <span class="n">stack_top</span><span class="p">,</span>   <span class="mi">8</span>
  <span class="o">.</span><span class="n">equ</span> <span class="n">stack_cap</span><span class="p">,</span>   <span class="mi">12</span>

  <span class="o">.</span><span class="n">equ</span> <span class="n">queue_size</span><span class="p">,</span>  <span class="mi">20</span>
  <span class="o">.</span><span class="n">equ</span> <span class="n">queue_array</span><span class="p">,</span> <span class="mi">0</span>
  <span class="o">.</span><span class="n">equ</span> <span class="n">queue_front</span><span class="p">,</span> <span class="mi">8</span>
  <span class="o">.</span><span class="n">equ</span> <span class="n">queue_back</span><span class="p">,</span>  <span class="mi">12</span>
  <span class="o">.</span><span class="n">equ</span> <span class="n">queue_cap</span><span class="p">,</span>   <span class="mi">16</span>

  <span class="o">.</span><span class="n">equ</span> <span class="n">tree_children</span><span class="p">,</span>     <span class="mi">0</span>
  <span class="o">.</span><span class="n">equ</span> <span class="n">tree_num_children</span><span class="p">,</span> <span class="mi">8</span>
  <span class="o">.</span><span class="n">equ</span> <span class="n">tree_value</span><span class="p">,</span>        <span class="mi">12</span>
  <span class="o">.</span><span class="n">equ</span> <span class="n">tree_size</span><span class="p">,</span>         <span class="mi">16</span>
<span class="o">.</span><span class="n">section</span> <span class="o">.</span><span class="n">text</span>
  <span class="o">.</span><span class="k">global</span> <span class="n">main</span>
  <span class="o">.</span><span class="n">extern</span> <span class="n">printf</span><span class="p">,</span> <span class="n">malloc</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">memcpy</span>

<span class="c1"># rdi - stack ptr</span>
<span class="n">get_stack</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="mi">32</span>                   <span class="c1"># Creating a 32 byte array</span>
  <span class="n">call</span>   <span class="n">malloc</span>
  <span class="n">mov</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span><span class="p">],</span> <span class="n">rax</span>      <span class="c1"># Saving the data into the stack</span>
  <span class="n">mov</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="mi">0</span>
  <span class="n">mov</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">12</span><span class="p">],</span> <span class="mi">32</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">ret</span>

<span class="c1"># rdi - stack ptr</span>
<span class="c1"># rsi - element ptr</span>
<span class="n">stack_push</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">push</span>   <span class="n">r13</span>
  <span class="n">push</span>   <span class="n">r14</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rdi</span>                  <span class="c1"># Saving the variables</span>
  <span class="n">mov</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">rsi</span>
  <span class="n">mov</span>    <span class="n">r14d</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">esi</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">12</span><span class="p">]</span>
  <span class="nb">cmp</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">r14</span>                  <span class="c1"># Check if top is equal to capacity</span>
  <span class="n">jne</span>    <span class="n">stack_push_append</span>
  <span class="n">shl</span>    <span class="n">rsi</span><span class="p">,</span> <span class="mi">1</span>                    <span class="c1"># Calculate new capacity in bytes</span>
  <span class="n">mov</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">12</span><span class="p">],</span> <span class="n">esi</span> <span class="c1"># Saving new capcaity</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="p">[</span><span class="n">r12</span><span class="p">]</span>
  <span class="n">call</span>   <span class="n">realloc</span>                   <span class="c1"># Making the array bigger</span>
  <span class="n">mov</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span><span class="p">],</span> <span class="n">rax</span>
<span class="n">stack_push_append</span><span class="p">:</span>
  <span class="n">add</span>    <span class="n">r14</span><span class="p">,</span> <span class="mi">8</span>
  <span class="n">mov</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span><span class="p">]</span>
  <span class="n">lea</span>    <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="n">r14</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rax</span><span class="p">],</span> <span class="n">r13</span>      <span class="c1"># Saving element and new top</span>
  <span class="n">mov</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">r14d</span>
  <span class="n">pop</span>    <span class="n">r14</span>
  <span class="n">pop</span>    <span class="n">r13</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">ret</span>

<span class="c1"># rdi - stack ptr</span>
<span class="c1"># RET rax - element ptr</span>
<span class="n">stack_pop</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">mov</span>    <span class="n">r12d</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span> <span class="c1"># Get top</span>
  <span class="n">test</span>   <span class="n">r12</span><span class="p">,</span> <span class="n">r12</span>                  <span class="c1"># Check if top is zero</span>
  <span class="n">jne</span>    <span class="n">stack_pop_element</span>
  <span class="n">xor</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>                  <span class="c1"># Return 0</span>
  <span class="n">jmp</span>    <span class="n">stack_pop_return</span>
<span class="n">stack_pop_element</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">rdi</span><span class="p">]</span>
  <span class="n">lea</span>    <span class="n">rax</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="n">r12</span><span class="p">]</span>          <span class="c1"># Get the element</span>
  <span class="n">mov</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rax</span><span class="p">]</span>
  <span class="n">sub</span>    <span class="n">r12</span><span class="p">,</span> <span class="mi">8</span>                    <span class="c1"># Subtract 1 from top and save it</span>
  <span class="n">mov</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">r12d</span>
<span class="n">stack_pop_return</span><span class="p">:</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">ret</span>

<span class="c1"># rdi - stack ptr</span>
<span class="n">free_stack</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span><span class="p">]</span>
  <span class="n">call</span>   <span class="n">free</span>                      <span class="c1"># Free stack array</span>
  <span class="n">ret</span>

<span class="c1"># rdi - queue ptr</span>
<span class="n">get_queue</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="mi">32</span>                  <span class="c1"># Create a 32 byte array</span>
  <span class="n">call</span>   <span class="n">malloc</span>
  <span class="n">mov</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span><span class="p">],</span> <span class="n">rax</span>     <span class="c1"># Saving data to the queue pointer</span>
  <span class="n">mov</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="mi">0</span>
  <span class="n">mov</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="mi">32</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">ret</span>

<span class="c1"># rdi - queue ptr</span>
<span class="n">queue_resize</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">push</span>   <span class="n">r13</span>
  <span class="n">push</span>   <span class="n">r14</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">mov</span>    <span class="n">edi</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span> <span class="c1"># Get new capacity and create new array</span>
  <span class="n">shl</span>    <span class="n">rdi</span><span class="p">,</span> <span class="mi">1</span>
  <span class="n">call</span>   <span class="n">malloc</span>
  <span class="n">mov</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">mov</span>    <span class="n">r14</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span><span class="p">[</span><span class="n">r12</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r13</span>                  <span class="c1"># Copy data from front to capacity</span>
  <span class="n">mov</span>    <span class="n">eax</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
  <span class="n">lea</span>    <span class="n">rsi</span><span class="p">,</span> <span class="p">[</span><span class="n">r14</span> <span class="o">+</span> <span class="n">rax</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">edx</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
  <span class="n">sub</span>    <span class="n">edx</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
  <span class="n">call</span>   <span class="n">memcpy</span>
  <span class="n">mov</span>    <span class="n">eax</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span> <span class="c1"># Copy data from start of array to front</span>
  <span class="n">sub</span>    <span class="n">eax</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
  <span class="n">lea</span>    <span class="n">rdi</span><span class="p">,</span> <span class="p">[</span><span class="n">r13</span> <span class="o">+</span> <span class="n">rax</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">r14</span>
  <span class="n">mov</span>    <span class="n">edx</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
  <span class="n">call</span>   <span class="n">memcpy</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r14</span>                  <span class="c1"># New array has front at 0 and back at the old capacity</span>
  <span class="n">call</span>   <span class="n">free</span>                      <span class="c1"># So free the old array then save the new queue</span>
  <span class="n">mov</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span><span class="p">],</span> <span class="n">r13</span>
  <span class="n">mov</span>    <span class="n">eax</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
  <span class="n">sub</span>    <span class="n">rax</span><span class="p">,</span> <span class="mi">8</span>
  <span class="n">mov</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">12</span><span class="p">],</span> <span class="n">eax</span>
  <span class="n">mov</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="mi">0</span>
  <span class="n">mov</span>    <span class="n">eax</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
  <span class="n">shl</span>    <span class="n">rax</span><span class="p">,</span> <span class="mi">1</span>
  <span class="n">mov</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="n">eax</span>
  <span class="n">pop</span>    <span class="n">r14</span>
  <span class="n">pop</span>    <span class="n">r13</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">ret</span>

<span class="c1"># rdi - queue ptr</span>
<span class="c1"># rsi - element</span>
<span class="n">enqueue</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">push</span>   <span class="n">r13</span>
  <span class="n">push</span>   <span class="n">r14</span>
  <span class="n">push</span>   <span class="n">r15</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rdi</span>                 <span class="c1"># Saving parameters</span>
  <span class="n">mov</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">rsi</span>
  <span class="n">mov</span>    <span class="n">r14d</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">eax</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">12</span><span class="p">]</span><span class="c1"># Calculating new back</span>
  <span class="n">add</span>    <span class="n">eax</span><span class="p">,</span> <span class="mi">8</span>
  <span class="n">mov</span>    <span class="n">edi</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
  <span class="n">cdq</span>
  <span class="n">idiv</span>   <span class="n">edi</span>
  <span class="nb">cmp</span>    <span class="n">rdx</span><span class="p">,</span> <span class="n">r14</span>                 <span class="c1"># Check if front and new back are equal</span>
  <span class="n">jne</span>    <span class="n">enqueue_append</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>                 <span class="c1"># If so resize the queue</span>
  <span class="n">call</span>   <span class="n">queue_resize</span>
<span class="n">enqueue_append</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">r14</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span><span class="p">]</span>     <span class="c1"># Saving the element</span>
  <span class="n">mov</span>    <span class="n">r15d</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">12</span><span class="p">]</span>
  <span class="n">lea</span>    <span class="n">r14</span><span class="p">,</span> <span class="p">[</span><span class="n">r14</span> <span class="o">+</span> <span class="n">r15</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r14</span><span class="p">],</span> <span class="n">r13</span>
  <span class="n">mov</span>    <span class="n">r14d</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span><span class="c1"># Calculating new back and then saving it</span>
  <span class="n">add</span>    <span class="n">r15</span><span class="p">,</span> <span class="mi">8</span>
  <span class="n">mov</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">r15</span>
  <span class="n">cdq</span>
  <span class="n">idiv</span>   <span class="n">r14d</span>
  <span class="n">mov</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">12</span><span class="p">],</span> <span class="n">edx</span>
  <span class="n">pop</span>    <span class="n">r15</span>
  <span class="n">pop</span>    <span class="n">r14</span>
  <span class="n">pop</span>    <span class="n">r13</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">ret</span>

<span class="c1"># rdi - queue ptr</span>
<span class="c1"># RET rax - element</span>
<span class="n">dequeue</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">push</span>   <span class="n">r13</span>
  <span class="n">mov</span>    <span class="n">r12d</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span> <span class="c1"># Check if queue is empty</span>
  <span class="n">mov</span>    <span class="n">r13d</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">12</span><span class="p">]</span>
  <span class="n">xor</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
  <span class="nb">cmp</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">r13</span>
  <span class="n">je</span>     <span class="n">dequeue_return</span>            <span class="c1"># if empty return null</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span><span class="p">]</span>      <span class="c1"># else return element pointer</span>
  <span class="n">mov</span>    <span class="n">r13d</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
  <span class="n">lea</span>    <span class="n">r13</span><span class="p">,</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="n">r13</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">eax</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
  <span class="n">add</span>    <span class="n">eax</span><span class="p">,</span> <span class="mi">8</span>
  <span class="n">mov</span>    <span class="n">r12d</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span> <span class="c1"># Calculate new front</span>
  <span class="n">cdq</span>
  <span class="n">idiv</span>   <span class="n">r12d</span>
  <span class="n">mov</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">edx</span>   <span class="c1"># Save new front</span>
  <span class="n">mov</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r13</span><span class="p">]</span>
<span class="n">dequeue_return</span><span class="p">:</span>
  <span class="n">pop</span>    <span class="n">r13</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">ret</span>

<span class="c1"># rdi - queue ptr</span>
<span class="n">free_queue</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span><span class="p">]</span>       <span class="c1"># Free queue array</span>
  <span class="n">call</span>   <span class="n">free</span>
  <span class="n">ret</span>

<span class="c1"># rdi - levels</span>
<span class="c1"># rsi - children_size</span>
<span class="c1"># RET rax:rdx - the tree - children|value|children_size</span>
<span class="n">create_tree</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">rbx</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">push</span>   <span class="n">r13</span>
  <span class="n">push</span>   <span class="n">r14</span>
  <span class="n">push</span>   <span class="n">r15</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">mov</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">rsi</span>
  <span class="n">test</span>   <span class="n">rdi</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">jz</span>     <span class="n">create_tree_leaf</span>
  <span class="n">mov</span>    <span class="n">r14</span><span class="p">,</span> <span class="n">rsi</span>                  <span class="c1"># We&#39;ll allocate sizeof(tree) * children_size bytes of memory</span>
  <span class="n">shl</span>    <span class="n">r14</span><span class="p">,</span> <span class="mi">4</span>                    <span class="c1"># save the size calculation to a callee-saved register so we can reuse it after the malloc</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r14</span>
  <span class="n">call</span>   <span class="n">malloc</span>
  <span class="n">mov</span>    <span class="n">r15</span><span class="p">,</span> <span class="n">rax</span>                  <span class="c1"># Save the children address twice, once for the return value, once for the loop variable</span>
  <span class="n">mov</span>    <span class="n">rbx</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">lea</span>    <span class="n">r14</span><span class="p">,</span> <span class="p">[</span><span class="n">rax</span> <span class="o">+</span> <span class="n">r14</span><span class="p">]</span>          <span class="c1"># Calculate the address of the element after last of the children array</span>
<span class="n">create_tree_children</span><span class="p">:</span>
  <span class="nb">cmp</span>    <span class="n">rbx</span><span class="p">,</span> <span class="n">r14</span>
  <span class="n">je</span>     <span class="n">create_tree_return</span>
  <span class="n">lea</span>    <span class="n">rdi</span><span class="p">,</span> <span class="p">[</span><span class="n">r12</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>            <span class="c1"># levels - 1</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">r13</span>
  <span class="n">call</span>   <span class="n">create_tree</span>
  <span class="n">mov</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rbx</span><span class="p">],</span> <span class="n">rax</span>      <span class="c1"># Save the created tree to memory</span>
  <span class="n">mov</span>    <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rbx</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="n">rdx</span>  <span class="c1"># The offset of children_size, writing out explicitly would&#39;ve made the line way too long</span>
  <span class="n">add</span>    <span class="n">rbx</span><span class="p">,</span> <span class="n">tree_size</span>
  <span class="n">jmp</span>    <span class="n">create_tree_children</span>
<span class="n">create_tree_leaf</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">r15</span><span class="p">,</span> <span class="mi">0</span>
  <span class="n">xor</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">r13</span>                  <span class="c1"># Leaves won&#39;t have any children</span>
<span class="n">create_tree_return</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">r15</span>                  <span class="c1"># The children pointer will be in r15</span>
  <span class="n">mov</span>    <span class="n">rdx</span><span class="p">,</span> <span class="n">r12</span>
  <span class="n">shl</span>    <span class="n">rdx</span><span class="p">,</span> <span class="mi">32</span>                   <span class="c1"># The tree&#39;s value will be the current &quot;levels&quot;</span>
  <span class="n">shl</span>    <span class="n">r13</span><span class="p">,</span> <span class="mi">4</span>
  <span class="ow">or</span>     <span class="n">rdx</span><span class="p">,</span> <span class="n">r13</span>                  <span class="c1"># Generate the return value by moving the value to the upper 32 bits</span>
  <span class="n">pop</span>    <span class="n">r15</span>
  <span class="n">pop</span>    <span class="n">r14</span>
  <span class="n">pop</span>    <span class="n">r13</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">pop</span>    <span class="n">rbx</span>
  <span class="n">ret</span>

<span class="c1"># rdi - children ptr</span>
<span class="c1"># rsi - children size</span>
<span class="n">free_tree</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">push</span>   <span class="n">r13</span>
  <span class="n">push</span>   <span class="n">r14</span>
  <span class="n">push</span>   <span class="n">r15</span>
  <span class="n">test</span>   <span class="n">rdi</span><span class="p">,</span> <span class="n">rdi</span>                 <span class="c1"># Make sure the pointer is non-zero</span>
  <span class="n">jz</span>     <span class="n">free_tree_return</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rdi</span>                 <span class="c1"># Saving array</span>
  <span class="n">lea</span>    <span class="n">r13</span><span class="p">,</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="n">rsi</span><span class="p">]</span>         <span class="c1"># Get start and end of the array</span>
  <span class="n">mov</span>    <span class="n">r14</span><span class="p">,</span> <span class="n">r12</span>
<span class="n">free_tree_free_kid</span><span class="p">:</span>
  <span class="nb">cmp</span>    <span class="n">r14</span><span class="p">,</span> <span class="n">r13</span>                 <span class="c1"># Loop thought the array and free all children</span>
  <span class="n">je</span>     <span class="n">free_tree_free_array</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r14</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">esi</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r14</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
  <span class="n">call</span>   <span class="n">free_tree</span>
  <span class="n">add</span>    <span class="n">r14</span><span class="p">,</span> <span class="n">tree_size</span>
  <span class="n">jmp</span>    <span class="n">free_tree_free_kid</span>
<span class="n">free_tree_free_array</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>                 <span class="c1"># Free the array</span>
  <span class="n">call</span>   <span class="n">free</span>
<span class="n">free_tree_return</span><span class="p">:</span>
  <span class="n">pop</span>    <span class="n">r15</span>
  <span class="n">pop</span>    <span class="n">r14</span>
  <span class="n">pop</span>    <span class="n">r13</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">ret</span>

<span class="c1"># rdi - children ptr</span>
<span class="c1"># rsi - value|children_size</span>
<span class="n">dfs_recursive</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">push</span>   <span class="n">r13</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">mov</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">rsi</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">OFFSET</span> <span class="n">fmt_tree</span>      <span class="c1"># Handle the current node</span>
  <span class="n">shr</span>    <span class="n">rsi</span><span class="p">,</span> <span class="mi">32</span>                   <span class="c1"># The tree value is in the upper 32 bits</span>
  <span class="n">xor</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>   <span class="n">printf</span>
  <span class="n">mov</span>    <span class="n">r13d</span><span class="p">,</span> <span class="n">r13d</span>                <span class="c1"># Zero out the top 32 bits</span>
  <span class="n">add</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">r12</span>                  <span class="c1"># Pointer pointing after the last element of the children array</span>
<span class="n">dfs_recursive_children</span><span class="p">:</span>
  <span class="nb">cmp</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">r13</span>                  <span class="c1"># If we reached the end, return</span>
  <span class="n">je</span>     <span class="n">dfs_recursive_return</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
  <span class="n">call</span>   <span class="n">dfs_recursive</span>
  <span class="n">add</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">tree_size</span>
  <span class="n">jmp</span>    <span class="n">dfs_recursive_children</span>
<span class="n">dfs_recursive_return</span><span class="p">:</span>
  <span class="n">pop</span>    <span class="n">r13</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">ret</span>

<span class="c1"># rdi - children ptr</span>
<span class="c1"># rsi - value|children_size</span>
<span class="n">dfs_recursive_postorder</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">push</span>   <span class="n">r13</span>
  <span class="n">push</span>   <span class="n">r14</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">mov</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">rsi</span>
  <span class="n">mov</span>    <span class="n">r14</span><span class="p">,</span> <span class="n">rsi</span>
  <span class="n">mov</span>    <span class="n">r13d</span><span class="p">,</span> <span class="n">r13d</span>                <span class="c1"># Zero out the top 32 bits</span>
  <span class="n">add</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">r12</span>                  <span class="c1"># Pointer pointing after the last element of the children array</span>
<span class="n">dfs_recursive_po_children</span><span class="p">:</span>
  <span class="nb">cmp</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">r13</span>                  <span class="c1"># If we reached the end, return</span>
  <span class="n">je</span>     <span class="n">dfs_recursive_po_return</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
  <span class="n">call</span>   <span class="n">dfs_recursive_postorder</span>
  <span class="n">add</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">tree_size</span>
  <span class="n">jmp</span>    <span class="n">dfs_recursive_po_children</span>
<span class="n">dfs_recursive_po_return</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">OFFSET</span> <span class="n">fmt_tree</span>      <span class="c1"># Handle the current node</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">r14</span>
  <span class="n">shr</span>    <span class="n">rsi</span><span class="p">,</span> <span class="mi">32</span>                   <span class="c1"># The tree value is in the upper 32 bits</span>
  <span class="n">xor</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>   <span class="n">printf</span>
  <span class="n">pop</span>    <span class="n">r14</span>
  <span class="n">pop</span>    <span class="n">r13</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">ret</span>

<span class="c1"># rdi - children ptr</span>
<span class="c1"># rsi - value|children_size</span>
<span class="n">dfs_recursive_inorder_btree</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">push</span>   <span class="n">r13</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rdi</span>
  <span class="n">mov</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">rsi</span>
  <span class="n">mov</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rsi</span>
  <span class="n">mov</span>    <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>
  <span class="nb">cmp</span>    <span class="n">rax</span><span class="p">,</span> <span class="mi">0</span>                    <span class="c1"># Check what type of tree it is.</span>
  <span class="n">je</span>     <span class="n">dfs_recursive_bt_size0</span>
  <span class="nb">cmp</span>    <span class="n">rax</span><span class="p">,</span> <span class="mi">16</span>
  <span class="n">je</span>     <span class="n">dfs_recursive_bt_size1</span>
  <span class="nb">cmp</span>    <span class="n">rax</span><span class="p">,</span> <span class="mi">32</span>
  <span class="n">je</span>     <span class="n">dfs_recursive_bt_size2</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">OFFSET</span> <span class="n">not_bt</span>        <span class="c1"># If the tree is not binary then print a warning</span>
  <span class="n">xor</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>   <span class="n">printf</span>
  <span class="n">jmp</span>    <span class="n">dfs_recursive_bt_return</span>
<span class="n">dfs_recursive_bt_size0</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">OFFSET</span> <span class="n">fmt_tree</span>      <span class="c1"># If the node is a leaf then print its id</span>
  <span class="n">shr</span>    <span class="n">rsi</span><span class="p">,</span> <span class="mi">32</span>
  <span class="n">xor</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>   <span class="n">printf</span>
  <span class="n">jmp</span>    <span class="n">dfs_recursive_bt_return</span>
<span class="n">dfs_recursive_bt_size1</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span><span class="p">]</span>      <span class="c1"># If the node has 1 child then call the function and print the id</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
  <span class="n">call</span>   <span class="n">dfs_recursive_inorder_btree</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">OFFSET</span> <span class="n">fmt_tree</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">r13</span>
  <span class="n">shr</span>    <span class="n">rsi</span><span class="p">,</span> <span class="mi">32</span>
  <span class="n">xor</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>   <span class="n">printf</span>
  <span class="n">jmp</span>    <span class="n">dfs_recursive_bt_return</span>
<span class="n">dfs_recursive_bt_size2</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span><span class="p">]</span>     <span class="c1"># Same as above just print id inbetween the calls</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
  <span class="n">call</span>   <span class="n">dfs_recursive_inorder_btree</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">OFFSET</span> <span class="n">fmt_tree</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">r13</span>
  <span class="n">shr</span>    <span class="n">rsi</span><span class="p">,</span> <span class="mi">32</span>
  <span class="n">xor</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>   <span class="n">printf</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">24</span><span class="p">]</span>
  <span class="n">call</span>   <span class="n">dfs_recursive_inorder_btree</span>
<span class="n">dfs_recursive_bt_return</span><span class="p">:</span>
  <span class="n">pop</span>    <span class="n">r13</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">ret</span>

<span class="c1"># rdi - children ptr</span>
<span class="c1"># rsi - value|children_size</span>
<span class="n">dfs_stack</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">push</span>   <span class="n">r13</span>
  <span class="n">push</span>   <span class="n">r14</span>
  <span class="n">sub</span>    <span class="n">rsp</span><span class="p">,</span> <span class="mi">16</span>                  <span class="c1"># Create stack</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rsp</span>
  <span class="n">push</span>   <span class="n">rsi</span>                      <span class="c1"># Save node to use as pointer</span>
  <span class="n">push</span>   <span class="n">rdi</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>
  <span class="n">call</span>   <span class="n">get_stack</span>                <span class="c1"># Init stack</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">rsp</span>
  <span class="n">call</span>   <span class="n">stack_push</span>               <span class="c1"># Push node</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>                 <span class="c1"># Pop stack</span>
  <span class="n">call</span>   <span class="n">stack_pop</span>
<span class="n">dfs_stack_loop</span><span class="p">:</span>
  <span class="n">test</span>   <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>                 <span class="c1"># Test if stack is empty</span>
  <span class="n">jz</span>     <span class="n">dfs_stack_return</span>
  <span class="n">mov</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">OFFSET</span> <span class="n">fmt_tree</span>     <span class="c1"># Print id</span>
  <span class="n">mov</span>    <span class="n">esi</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r13</span> <span class="o">+</span> <span class="mi">12</span><span class="p">]</span>
  <span class="n">xor</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>   <span class="n">printf</span>
  <span class="n">mov</span>    <span class="n">eax</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r13</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span> <span class="c1"># Get start and end of array</span>
  <span class="n">mov</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r13</span><span class="p">]</span>
  <span class="n">lea</span>    <span class="n">r14</span><span class="p">,</span> <span class="p">[</span><span class="n">r13</span> <span class="o">+</span> <span class="n">rax</span><span class="p">]</span>
<span class="n">dfs_stack_push_child</span><span class="p">:</span>
  <span class="nb">cmp</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">r14</span>                 <span class="c1"># Check if the pointers are the same</span>
  <span class="n">je</span>     <span class="n">dfs_stack_end_push</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>                 <span class="c1"># Push node into the stack</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">r13</span>
  <span class="n">call</span>   <span class="n">stack_push</span>
  <span class="n">add</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">tree_size</span>
  <span class="n">jmp</span>    <span class="n">dfs_stack_push_child</span>
<span class="n">dfs_stack_end_push</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>                 <span class="c1"># Pop stack</span>
  <span class="n">call</span>   <span class="n">stack_pop</span>
  <span class="n">jmp</span>    <span class="n">dfs_stack_loop</span>
<span class="n">dfs_stack_return</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>                 <span class="c1"># Free stack</span>
  <span class="n">call</span>   <span class="n">free_stack</span>
  <span class="n">add</span>    <span class="n">rsp</span><span class="p">,</span> <span class="mi">32</span>
  <span class="n">pop</span>    <span class="n">r14</span>
  <span class="n">pop</span>    <span class="n">r13</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">ret</span>

<span class="c1"># rdi - children ptr</span>
<span class="c1"># rsi - value|children_size</span>
<span class="n">bfs_queue</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">push</span>   <span class="n">r13</span>
  <span class="n">push</span>   <span class="n">r14</span>
  <span class="n">sub</span>    <span class="n">rsp</span><span class="p">,</span> <span class="mi">20</span>                  <span class="c1"># Create queue</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rsp</span>
  <span class="n">push</span>   <span class="n">rsi</span>                      <span class="c1"># Save node to use as pointer</span>
  <span class="n">push</span>   <span class="n">rdi</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>
  <span class="n">call</span>   <span class="n">get_queue</span>                <span class="c1"># Init queue</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">rsp</span>
  <span class="n">call</span>   <span class="n">enqueue</span>                  <span class="c1"># enqueue node</span>
  <span class="n">mov</span>    <span class="n">eax</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">edi</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">12</span><span class="p">]</span>
<span class="n">bfs_queue_loop</span><span class="p">:</span>
  <span class="nb">cmp</span>    <span class="n">eax</span><span class="p">,</span> <span class="n">edi</span>
  <span class="n">je</span>     <span class="n">bfs_queue_return</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>                 <span class="c1"># dequeue</span>
  <span class="n">call</span>   <span class="n">dequeue</span>
  <span class="n">test</span>   <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>                 <span class="c1"># Test if queue is empty</span>
  <span class="n">jz</span>     <span class="n">bfs_queue_return</span>
  <span class="n">mov</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">OFFSET</span> <span class="n">fmt_tree</span>     <span class="c1"># Print id</span>
  <span class="n">mov</span>    <span class="n">esi</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r13</span> <span class="o">+</span> <span class="mi">12</span><span class="p">]</span>
  <span class="n">xor</span>    <span class="n">rax</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">call</span>   <span class="n">printf</span>
  <span class="n">mov</span>    <span class="n">eax</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r13</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span> <span class="c1"># Get start and end of array</span>
  <span class="n">mov</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r13</span><span class="p">]</span>
  <span class="n">lea</span>    <span class="n">r14</span><span class="p">,</span> <span class="p">[</span><span class="n">r13</span> <span class="o">+</span> <span class="n">rax</span><span class="p">]</span>
<span class="n">bfs_queue_push_child</span><span class="p">:</span>
  <span class="nb">cmp</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">r14</span>                 <span class="c1"># Check if the pointers are the same</span>
  <span class="n">je</span>     <span class="n">bfs_queue_end_push</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>                 <span class="c1"># enqueue node</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">r13</span>
  <span class="n">call</span>   <span class="n">enqueue</span>
  <span class="n">add</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">tree_size</span>
  <span class="n">jmp</span>    <span class="n">bfs_queue_push_child</span>
<span class="n">bfs_queue_end_push</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">eax</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
  <span class="n">mov</span>    <span class="n">edi</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">r12</span> <span class="o">+</span> <span class="mi">12</span><span class="p">]</span>
  <span class="n">jmp</span>    <span class="n">bfs_queue_loop</span>
<span class="n">bfs_queue_return</span><span class="p">:</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>                 <span class="c1"># Free queue</span>
  <span class="n">call</span>   <span class="n">free_queue</span>
  <span class="n">add</span>    <span class="n">rsp</span><span class="p">,</span> <span class="mi">36</span>
  <span class="n">pop</span>    <span class="n">r14</span>
  <span class="n">pop</span>    <span class="n">r13</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">ret</span>

<span class="n">main</span><span class="p">:</span>
  <span class="n">push</span>   <span class="n">r12</span>
  <span class="n">push</span>   <span class="n">r13</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="mi">3</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="mi">3</span>
  <span class="n">call</span>   <span class="n">create_tree</span>
  <span class="n">mov</span>    <span class="n">r12</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">mov</span>    <span class="n">r13</span><span class="p">,</span> <span class="n">rdx</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">rax</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">rdx</span>
  <span class="n">call</span>   <span class="n">bfs_queue</span>
  <span class="n">mov</span>    <span class="n">rdi</span><span class="p">,</span> <span class="n">r12</span>
  <span class="n">mov</span>    <span class="n">rsi</span><span class="p">,</span> <span class="n">r13</span>
  <span class="n">mov</span>    <span class="n">esi</span><span class="p">,</span> <span class="n">esi</span>
  <span class="n">call</span>   <span class="n">free_tree</span>
  <span class="n">pop</span>    <span class="n">r13</span>
  <span class="n">pop</span>    <span class="n">r12</span>
  <span class="n">ret</span>
</pre></div>

</div></p>
</div><div class="emojic">
<p><div class="codehilite">
<div class="highlight"><pre><span></span><span class="err">ü¶É</span> <span class="err">‚èπ</span> <span class="err">üçá</span>
  <span class="err">üîò</span> <span class="err">‚è´</span>

  <span class="err">‚ùóÔ∏è</span> <span class="err">üî°</span> <span class="err">‚û°Ô∏è</span> <span class="err">üî°</span> <span class="err">üçá</span>
    <span class="err">‚Ü™Ô∏è</span> <span class="err">üêï</span> <span class="err">üôå</span> <span class="err">üÜï‚èπ‚è´‚ùóÔ∏è</span> <span class="err">üçá</span>
      <span class="err">‚Ü©Ô∏è</span> <span class="err">üî§</span><span class="n">The</span> <span class="n">given</span> <span class="n">tree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">binary</span><span class="err">!üî§</span>
    <span class="err">üçâ</span>
    <span class="err">‚Ü©Ô∏è</span> <span class="err">üî§üî§</span>
  <span class="err">üçâ</span>
<span class="err">üçâ</span>

<span class="err">üêá</span> <span class="err">üå≤</span> <span class="err">üçá</span>
  <span class="err">üñçüÜï</span> <span class="nb">id</span> <span class="err">üî¢</span>
  <span class="err">üñçüÜï</span> <span class="n">children</span> <span class="err">üç®üêöüå≤üçÜ</span>

  <span class="err">üÜï</span> <span class="n">depth_count</span> <span class="err">üî¢</span> <span class="n">children_count</span> <span class="err">üî¢</span> <span class="err">üçá</span>
    <span class="mi">1</span> <span class="err">‚û°Ô∏è</span> <span class="err">üñç</span><span class="nb">id</span>
    <span class="err">üç®üçÜ</span> <span class="err">‚û°Ô∏è</span> <span class="err">üñç</span><span class="n">children</span>

    <span class="err">üååüêï</span> <span class="n">depth_count</span> <span class="n">children_count</span><span class="err">‚ùóÔ∏è</span>
  <span class="err">üçâ</span>

  <span class="err">üîê</span> <span class="err">üÜï</span> <span class="err">‚≠êÔ∏è</span> <span class="n">given_id</span> <span class="err">üî¢</span> <span class="n">depth_count</span> <span class="err">üî¢</span> <span class="n">children_count</span> <span class="err">üî¢</span> <span class="err">üçá</span>
    <span class="n">given_id</span> <span class="err">‚û°Ô∏è</span> <span class="err">üñç</span><span class="nb">id</span>
    <span class="err">üç®üçÜ</span> <span class="err">‚û°Ô∏è</span> <span class="err">üñç</span><span class="n">children</span>

    <span class="err">üååüêï</span> <span class="n">depth_count</span> <span class="n">children_count</span><span class="err">‚ùóÔ∏è</span>
  <span class="err">üçâ</span>

  <span class="err">‚ùóÔ∏è</span> <span class="err">üÜî</span> <span class="err">‚û°Ô∏è</span> <span class="err">üî¢</span> <span class="err">üçá</span>
    <span class="err">‚Ü©Ô∏è</span> <span class="nb">id</span>
  <span class="err">üçâ</span>

  <span class="err">‚ùóÔ∏è</span> <span class="err">üßí</span> <span class="err">‚û°Ô∏è</span> <span class="err">üç®üêöüå≤üçÜ</span> <span class="err">üçá</span>
    <span class="err">‚Ü©Ô∏è</span> <span class="n">children</span>
  <span class="err">üçâ</span>

  <span class="err">üìó</span> <span class="n">Depth</span><span class="o">-</span><span class="n">First</span> <span class="n">Search</span> <span class="n">Recursive</span> <span class="n">pre</span><span class="o">-</span><span class="n">order</span> <span class="err">üìó</span>
  <span class="err">‚ùóÔ∏è</span> <span class="err">üåÄ</span> <span class="err">üçá</span>
    <span class="err">üòÄ</span> <span class="err">üî°</span> <span class="nb">id</span> <span class="mi">10</span><span class="err">‚ùóÔ∏è‚ùóÔ∏è</span>

    <span class="err">üîÇ</span> <span class="n">child</span> <span class="n">children</span> <span class="err">üçá</span>
      <span class="err">üåÄ</span> <span class="n">child</span><span class="err">‚ùóÔ∏è</span>
    <span class="err">üçâ</span>
  <span class="err">üçâ</span>

  <span class="err">üìó</span> <span class="n">Depth</span><span class="o">-</span><span class="n">First</span> <span class="n">Search</span> <span class="n">Recursive</span> <span class="n">post</span><span class="o">-</span><span class="n">order</span> <span class="err">üìó</span>
  <span class="err">‚ùóÔ∏è</span> <span class="err">üç•</span> <span class="err">üçá</span>
    <span class="err">üîÇ</span> <span class="n">child</span> <span class="n">children</span> <span class="err">üçá</span>
      <span class="err">üç•</span> <span class="n">child</span><span class="err">‚ùóÔ∏è</span>
    <span class="err">üçâ</span>

    <span class="err">üòÄ</span> <span class="err">üî°</span> <span class="nb">id</span> <span class="mi">10</span><span class="err">‚ùóÔ∏è‚ùóÔ∏è</span>
  <span class="err">üçâ</span>

  <span class="err">üìó</span>
    <span class="n">Depth</span><span class="o">-</span><span class="n">First</span> <span class="n">Search</span> <span class="n">Recursive</span> <span class="n">Inorder</span> <span class="n">Binary</span>
    <span class="n">This</span> <span class="n">assumes</span> <span class="n">only</span> <span class="mi">2</span> <span class="n">children</span><span class="o">.</span>
  <span class="err">üìó</span>
  <span class="err">‚ùóÔ∏è</span> <span class="err">üç≠</span> <span class="err">‚û°Ô∏è</span> <span class="err">üç¨‚èπ</span> <span class="err">üçá</span>
    <span class="err">‚Ü™Ô∏è</span> <span class="err">üêî</span> <span class="n">children</span><span class="err">‚ùóÔ∏è</span> <span class="err">‚ñ∂Ô∏è</span> <span class="mi">2</span> <span class="err">üçá</span>
      <span class="err">‚Ü©Ô∏è</span> <span class="err">üÜï‚èπ‚è´‚ùóÔ∏è</span>
    <span class="err">üçâ</span>

    <span class="err">‚Ü™Ô∏è</span> <span class="err">üêî</span> <span class="n">children</span><span class="err">‚ùóÔ∏è</span> <span class="err">‚ñ∂Ô∏è</span> <span class="mi">0</span> <span class="err">üçá</span>
      <span class="err">üç≠üêΩ</span> <span class="n">children</span> <span class="mi">0</span><span class="err">‚ùóÔ∏è‚ùóÔ∏è</span>
      <span class="err">üòÄ</span> <span class="err">üî°</span> <span class="nb">id</span> <span class="mi">10</span><span class="err">‚ùóÔ∏è‚ùóÔ∏è</span>
      <span class="err">üç≠üêΩ</span> <span class="n">children</span> <span class="mi">1</span><span class="err">‚ùóÔ∏è‚ùóÔ∏è</span>
    <span class="err">üçâ</span>
    <span class="err">üôÖ</span> <span class="err">üçá</span>
      <span class="err">üòÄ</span> <span class="err">üî°</span> <span class="nb">id</span> <span class="mi">10</span><span class="err">‚ùóÔ∏è‚ùóÔ∏è</span>
    <span class="err">üçâ</span>
    <span class="err">‚Ü©Ô∏è</span> <span class="err">ü§∑‚Äç‚ôÄÔ∏è</span>
  <span class="err">üçâ</span>

  <span class="err">üìó</span> <span class="n">Depth</span><span class="o">-</span><span class="n">First</span> <span class="n">Search</span> <span class="n">Stack</span> <span class="err">üìó</span>
  <span class="err">‚ùóÔ∏è</span> <span class="err">ü•û</span> <span class="err">üçá</span>
    <span class="err">üç®</span> <span class="err">üêï</span> <span class="err">üçÜ</span> <span class="err">‚û°Ô∏è</span> <span class="n">stack</span>

    <span class="err">üîÅ</span> <span class="err">‚ùé</span> <span class="err">üêî</span> <span class="n">stack</span><span class="err">‚ùóÔ∏è</span> <span class="err">üôå</span>  <span class="mi">0</span><span class="err">‚ùóÔ∏è</span> <span class="err">üçá</span>
      <span class="err">üêΩ</span> <span class="n">stack</span> <span class="err">üêî</span> <span class="n">stack</span><span class="err">‚ùóÔ∏è</span> <span class="err">‚ûñ</span> <span class="mi">1</span><span class="err">‚ùóÔ∏è</span> <span class="err">‚û°Ô∏è</span> <span class="n">temp</span>
      <span class="err">üê®</span> <span class="n">stack</span> <span class="err">üêî</span> <span class="n">stack</span><span class="err">‚ùóÔ∏è</span> <span class="err">‚ûñ</span> <span class="mi">1</span><span class="err">‚ùóÔ∏è</span>

      <span class="err">üòÄ</span> <span class="err">üî°</span> <span class="err">üÜî</span> <span class="n">temp</span><span class="err">‚ùóÔ∏è</span> <span class="mi">10</span><span class="err">‚ùóÔ∏è‚ùóÔ∏è</span>

      <span class="err">üßí</span> <span class="n">temp</span><span class="err">‚ùóÔ∏è</span> <span class="err">‚û°Ô∏è</span> <span class="n">temp_children</span>
      <span class="err">üîÇ</span> <span class="n">child</span> <span class="n">temp_children</span> <span class="err">üçá</span>
        <span class="err">üêª</span> <span class="n">stack</span> <span class="n">child</span><span class="err">‚ùóÔ∏è</span>
      <span class="err">üçâ</span>
    <span class="err">üçâ</span>
  <span class="err">üçâ</span>

  <span class="err">üìó</span> <span class="n">Breadth</span><span class="o">-</span><span class="n">First</span> <span class="n">Search</span> <span class="n">Queue</span> <span class="err">üìó</span>
  <span class="err">‚ùóÔ∏è</span> <span class="err">üè¢</span> <span class="err">üçá</span>
    <span class="err">üç®</span> <span class="err">üêï</span> <span class="err">üçÜ</span> <span class="err">‚û°Ô∏è</span> <span class="n">queue</span>

    <span class="err">üîÅ</span> <span class="err">‚ùé</span> <span class="err">üêî</span> <span class="n">queue</span><span class="err">‚ùóÔ∏è</span> <span class="err">üôå</span>  <span class="mi">0</span><span class="err">‚ùóÔ∏è</span> <span class="err">üçá</span>
      <span class="err">üêΩ</span> <span class="n">queue</span> <span class="mi">0</span><span class="err">‚ùóÔ∏è</span> <span class="err">‚û°Ô∏è</span> <span class="n">temp</span>
      <span class="err">üê®</span> <span class="n">queue</span> <span class="mi">0</span><span class="err">‚ùóÔ∏è</span>

      <span class="err">üòÄ</span> <span class="err">üî°</span> <span class="err">üÜî</span> <span class="n">temp</span><span class="err">‚ùóÔ∏è</span> <span class="mi">10</span><span class="err">‚ùóÔ∏è‚ùóÔ∏è</span>

      <span class="err">üßí</span> <span class="n">temp</span><span class="err">‚ùóÔ∏è</span> <span class="err">‚û°Ô∏è</span> <span class="n">temp_children</span>
      <span class="err">üîÇ</span> <span class="n">child</span> <span class="n">temp_children</span> <span class="err">üçá</span>
        <span class="err">üêª</span> <span class="n">queue</span> <span class="n">child</span><span class="err">‚ùóÔ∏è</span>
      <span class="err">üçâ</span>
    <span class="err">üçâ</span>
  <span class="err">üçâ</span>

  <span class="err">üîê</span> <span class="err">‚ùóÔ∏è</span> <span class="err">üåå</span> <span class="n">depth_count</span> <span class="err">üî¢</span> <span class="n">children_count</span> <span class="err">üî¢</span> <span class="err">üçá</span>
    <span class="err">‚Ü™Ô∏è</span> <span class="err">‚ùé</span> <span class="n">depth_count</span> <span class="err">‚óÄÔ∏èüôå</span> <span class="mi">1</span><span class="err">‚ùóÔ∏è</span> <span class="err">üçá</span>
      <span class="err">üîÇ</span> <span class="n">i</span> <span class="err">üÜï‚è©‚è©</span> <span class="mi">0</span> <span class="n">children_count</span><span class="err">‚ùóÔ∏è</span> <span class="err">üçá</span>
        <span class="err">üêª</span> <span class="n">children</span> <span class="err">üÜïüå≤‚≠êÔ∏è</span> <span class="err">ü§ú</span><span class="nb">id</span> <span class="err">‚úñÔ∏è</span> <span class="mi">10</span> <span class="err">‚ûï</span> <span class="n">i</span> <span class="err">‚ûï</span> <span class="mi">1</span><span class="err">ü§õ</span> <span class="err">ü§ú</span><span class="n">depth_count</span> <span class="err">‚ûñ</span> <span class="mi">1</span><span class="err">ü§õ</span> <span class="n">children_count</span><span class="err">‚ùóÔ∏è‚ùóÔ∏è</span>
      <span class="err">üçâ</span>
    <span class="err">üçâ</span>
  <span class="err">üçâ</span>
<span class="err">üçâ</span>

<span class="err">üèÅ</span> <span class="err">üçá</span>
  <span class="err">üÜïüå≤üÜï</span> <span class="mi">3</span> <span class="mi">3</span><span class="err">‚ùóÔ∏è</span> <span class="err">‚û°Ô∏è</span> <span class="n">tree</span>
  <span class="err">üòÄ</span> <span class="err">üî§</span><span class="n">Tree</span> <span class="n">Traversal</span><span class="err">üî§Ô∏è‚ùóÔ∏è</span>
  <span class="err">üòÄ</span> <span class="err">üî§üåÄ</span>  <span class="o">-</span> <span class="n">Depth</span><span class="o">-</span><span class="n">First</span> <span class="n">Search</span> <span class="n">Recursive</span> <span class="n">pre</span><span class="o">-</span><span class="n">order</span><span class="err">üî§‚ùóÔ∏è</span>
  <span class="err">üåÄ</span><span class="n">tree</span><span class="err">‚ùóÔ∏è</span>
  <span class="err">üòÄ</span> <span class="err">üî§üç•</span>  <span class="o">-</span> <span class="n">Depth</span><span class="o">-</span><span class="n">First</span> <span class="n">Search</span> <span class="n">Recursive</span> <span class="n">post</span><span class="o">-</span><span class="n">order</span><span class="err">üî§‚ùóÔ∏è</span>
  <span class="err">üç•</span><span class="n">tree</span><span class="err">‚ùóÔ∏è</span>
  <span class="err">üòÄ</span> <span class="err">üî§ü•û</span>  <span class="o">-</span> <span class="n">Depth</span><span class="o">-</span><span class="n">First</span> <span class="n">Search</span> <span class="n">Stack</span><span class="err">üî§‚ùóÔ∏è</span>
  <span class="err">ü•û</span><span class="n">tree</span><span class="err">‚ùóÔ∏è</span>
  <span class="err">üòÄ</span> <span class="err">üî§üè¢</span>  <span class="o">-</span> <span class="n">Breadth</span><span class="o">-</span><span class="n">First</span> <span class="n">Search</span> <span class="n">Queue</span><span class="err">üî§‚ùóÔ∏è</span>
  <span class="err">üè¢</span><span class="n">tree</span><span class="err">‚ùóÔ∏è</span>

  <span class="err">üòÄ</span> <span class="err">üî§üç≠</span>  <span class="o">-</span> <span class="n">Depth</span><span class="o">-</span><span class="n">First</span> <span class="n">Search</span> <span class="n">Recursive</span> <span class="n">Inorder</span> <span class="n">Binary</span> <span class="o">-</span> <span class="n">Error</span><span class="err">üî§‚ùóÔ∏è</span>
  <span class="err">üí≠</span> <span class="n">Calling</span> <span class="n">the</span> <span class="n">Depth</span><span class="o">-</span><span class="n">First</span> <span class="n">Search</span> <span class="n">Recursive</span> <span class="n">Inorder</span> <span class="n">Binary</span> <span class="n">method</span> <span class="n">here</span> <span class="n">does</span>
  <span class="err">üí≠</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">an</span> <span class="n">error</span><span class="p">,</span> <span class="n">since</span> <span class="s2">&quot;tree&quot;</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">a</span> <span class="n">binary</span> <span class="n">tree</span><span class="o">.</span>
  <span class="err">Ô∏è‚Ü™Ô∏è</span> <span class="err">üç≠</span><span class="n">tree</span><span class="err">‚ùóÔ∏è</span> <span class="err">‚û°Ô∏è</span> <span class="k">return</span> <span class="err">üçá</span>
    <span class="err">üòÄ</span> <span class="err">üî°</span><span class="k">return</span><span class="err">‚ùó‚ùóÔ∏èÔ∏è</span>
  <span class="err">üçâ</span>

  <span class="err">üÜïüå≤üÜï</span> <span class="mi">3</span> <span class="mi">2</span><span class="err">‚ùóÔ∏è</span> <span class="err">‚û°Ô∏è</span> <span class="n">binary_tree</span>
  <span class="err">üòÄ</span> <span class="err">üî§üç≠</span>  <span class="o">-</span> <span class="n">Depth</span><span class="o">-</span><span class="n">First</span> <span class="n">Search</span> <span class="n">Recursive</span> <span class="n">Inorder</span> <span class="n">Binary</span><span class="err">üî§‚ùóÔ∏è</span>
  <span class="err">Ô∏è‚Ü™Ô∏è</span> <span class="err">üç≠</span><span class="n">binary_tree</span><span class="err">‚ùóÔ∏è</span> <span class="err">‚û°Ô∏è</span> <span class="k">return</span> <span class="err">üçá</span>
    <span class="err">üòÄ</span> <span class="err">üî°</span><span class="k">return</span><span class="err">‚ùó‚ùóÔ∏èÔ∏è</span>
  <span class="err">üçâ</span>
<span class="err">üçâ</span>
</pre></div>

</div></p>
</div>
</div>

<script>
MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
</script>

<h2>License</h2>
<h5>Code Examples</h5>
<p>The code examples are licensed under the MIT license (found in <a href="https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md">LICENSE.md</a>).</p>
<h5>Text</h5>
<p>The text of this chapter was written by <a href="https://github.com/leios">James Schloss</a> and is licensed under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><p><img  class="center" src="../cc/CC-BY-SA_icon.svg" /></p></a></p>
<h5>Images/Graphics</h5>
<ul>
<li>The image "<a href="res/DFS_pre.png">DFSpreorder</a>" was created by <a href="https://github.com/leios">James Schloss</a> and is licenced under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image "<a href="res/DFS_post.png">DFSpostorder</a>" was created by <a href="https://github.com/leios">James Schloss</a> and is licenced under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image "<a href="res/DFS_in.png">DFSinorder</a>" was created by <a href="https://github.com/leios">James Schloss</a> and is licenced under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>The image "<a href="res/BFS_simple.png">BFSsimple</a>" was created by <a href="https://github.com/leios">James Schloss</a> and is licenced under the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
</ul>
<h5>Pull Requests</h5>
<p>After initial licensing (<a href="https://github.com/algorithm-archivists/algorithm-archive/pull/560">#560</a>), the following pull requests have modified the text or graphics of this chapter:
- none</p>
        <hr>
    </div>
</body>
</html>